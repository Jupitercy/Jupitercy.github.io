<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>小程序开发学习笔记(一)</title>
      <link href="/2023/01/07/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
      <url>/2023/01/07/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<p>来源：b站黑马程序员小程序开发<br>传送门：<a href="https://www.bilibili.com/video/BV1834y1676P/?spm_id_from=333.337.search-card.all.click&amp;vd_source=dc5d5f18d3446b961e362e2e21df37df">https://www.bilibili.com/video/BV1834y1676P/?spm_id_from=333.337.search-card.all.click&amp;vd_source=dc5d5f18d3446b961e362e2e21df37df</a></p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><ul><li>pages 存放小程序所有页面</li><li>utils 存放工具性质的模块（例如格式化时间的自定义模块）</li><li>app.js 小程序项目的入口文件</li><li>app.json 小程序项目全局配置文件</li><li>app.wxss 小程序全局样式文件</li><li>project.config.json 项目配置文件</li><li>sitemap.json 配置小程序及其页面是否允许被微信索引</li></ul><h3 id="页面组成部分"><a href="#页面组成部分" class="headerlink" title="页面组成部分"></a>页面组成部分</h3><p>每个页面以单独文件夹存在</p><ul><li>.js 页面脚本文件，存放页面数据、事件处理函数等</li><li>.json 页面配置文件，配置窗口外观、表现</li><li>.wxml 页面模板结果</li><li>.wxss 页面样式表</li></ul><h3 id="json配置文件"><a href="#json配置文件" class="headerlink" title="json配置文件"></a>json配置文件</h3><h4 id="app-json"><a href="#app-json" class="headerlink" title="app.json"></a>app.json</h4><p>当前小程序的全局配置，包括所有页面路径、窗口外观、界面表现、底部tab</p><ul><li>pages 记录当前小程序所有页面路径</li><li>window 全局定义小程序所有页面的背景色、文字颜色等</li><li>style 全局定义小程序所使用的样式版本</li><li>sitemapLocation 指明sitemap.json 的位置</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;pages&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;pages/index/index&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;pages/logs/logs&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;window&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;backgroundTextStyle&quot;</span><span class="punctuation">:</span><span class="string">&quot;dark&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;navigationBarBackgroundColor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#2b4b6b&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;navigationBarTitleText&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xxx&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;navigationBarTextStyle&quot;</span><span class="punctuation">:</span><span class="string">&quot;white&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;style&quot;</span><span class="punctuation">:</span> <span class="string">&quot;v2&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sitemapLocation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sitemap.json&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="project-config-json"><a href="#project-config-json" class="headerlink" title="project.config.json"></a>project.config.json</h4><p>记录对小程序开发工具做的个性化设置</p><ul><li>setting 保存编译相关的配置</li><li>projectname 保存项目名称</li><li>appid 保存小程序账号ID</li></ul><h4 id="sitemap-json"><a href="#sitemap-json" class="headerlink" title="sitemap.json"></a>sitemap.json</h4><p>微信已开放小程序内搜索，sitemap.json用来配置小程序页面是否允许微信索引。</p><p>当开发者允许微信索引时，微信通过爬虫的形式，为小程序页面建立索引。当用户的搜索关键字和页面的索引匹配成功时候，小程序页面会展示在搜索结果中。</p><h4 id="页面-json"><a href="#页面-json" class="headerlink" title="页面 .json"></a>页面 .json</h4><p>页面中的配置项会覆盖app.json中的window中相同的配置项</p><h3 id="wxml模板"><a href="#wxml模板" class="headerlink" title="wxml模板"></a>wxml模板</h3><p>类似于网页开发中的html</p><h4 id="与html区别"><a href="#与html区别" class="headerlink" title="与html区别"></a>与html区别</h4><ul><li>标签名称不同<ul><li>html：div span img a</li><li>wxml：view text image navigator</li></ul></li><li>属性节点不同<ul><li><code>&lt;a href=&quot;#&quot;&gt;超链接&lt;/a&gt;a</code></li><li><code>&lt;navigator url=&quot;/pages/homes/home&quot;&gt;&lt;/navigator&gt;</code></li></ul></li><li>提供了类似vue的模板语法<ul><li>数据绑定</li><li>列表渲染</li><li>条件渲染</li></ul></li></ul><h3 id="wxss模板"><a href="#wxss模板" class="headerlink" title="wxss模板"></a>wxss模板</h3><ul><li>新增了 rpx 尺寸单位</li><li>提供了全局的样式和局部样式</li><li>WXSS 仅支持部分 CSS 选择器</li></ul><h3 id="js逻辑交互"><a href="#js逻辑交互" class="headerlink" title="js逻辑交互"></a>js逻辑交互</h3><p>处理用户操作，例如获取用户地址，响应用户行为</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><h5 id="app-js"><a href="#app-js" class="headerlink" title="app.js"></a>app.js</h5><p>项目入口文件，通过调用APP（）函数来启动整个小程序</p><h5 id="页面-js"><a href="#页面-js" class="headerlink" title="页面.js"></a>页面.js</h5><p>页面入口文件，调用Page()函数创建并允许页面</p><h5 id="普通-js文件"><a href="#普通-js文件" class="headerlink" title="普通.js文件"></a>普通.js文件</h5><p>普通功能模块文件，用来封装公共的函数或属性供页面使用</p><h2 id="宿主环境"><a href="#宿主环境" class="headerlink" title="宿主环境"></a>宿主环境</h2><p>小程序宿主环境是微信</p><h3 id="宿主环境包含内容"><a href="#宿主环境包含内容" class="headerlink" title="宿主环境包含内容"></a>宿主环境包含内容</h3><ul><li>通信模型</li><li>运行机制</li><li>组件</li><li>API</li></ul><h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3><h4 id="主体"><a href="#主体" class="headerlink" title="主体"></a>主体</h4><p>通信主体是渲染层和逻辑层</p><ul><li>wxml模板和wxss样式工作在渲染层</li><li>js脚本工作在逻辑层</li></ul><h4 id="通信模型"><a href="#通信模型" class="headerlink" title="通信模型"></a>通信模型</h4><p>分为两部分</p><ul><li>渲染层和逻辑层之间的通信：由微信客户端进行转发</li><li>逻辑层和第三方之间的通信：由微信客户端进行转发</li></ul><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><h4 id="小程序启动过程"><a href="#小程序启动过程" class="headerlink" title="小程序启动过程"></a>小程序启动过程</h4><ol><li>把小程序代码包下载到本地</li><li>解析app.json全局配置文件</li><li>执行app.js 小程序入口文件，<strong>调用App()创建小程序实例</strong></li><li>渲染小程序首页</li><li>小程序启动完成</li></ol><h4 id="页面渲染过程"><a href="#页面渲染过程" class="headerlink" title="页面渲染过程"></a>页面渲染过程</h4><ol><li>加载并解析页面的.json配置文件</li><li>加载页面的.wxml模板和.wxss样式</li><li>执行页面的.js文件，<strong>调用Page()创建页面实例</strong></li><li>页面渲染完成</li></ol><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><h4 id="组件分类"><a href="#组件分类" class="headerlink" title="组件分类"></a>组件分类</h4><p>组件也是宿主环境提供的，分为9大类</p><ol><li><strong>视图容器</strong></li><li><strong>基础内容</strong></li><li><strong>表单组件</strong></li><li><strong>导航组件</strong></li><li>媒体地图</li><li>map地图组件</li><li>canvas画布组件</li><li>开放能力</li><li>无障碍访问</li></ol><h4 id="常用视图容器类组件"><a href="#常用视图容器类组件" class="headerlink" title="常用视图容器类组件"></a>常用视图容器类组件</h4><ol><li>view<ul><li>普通视图区域</li><li>类似于html中的div，是一个块级元素</li><li>用来实现页面的布局效果</li></ul></li><li>scroll-view<ul><li>可滚动的视图区域</li><li>常用来实现滚动列表效果</li></ul></li><li>swiper和swiper-item<ul><li>轮播图容器组件和轮播图item组件</li></ul></li></ol><h4 id="常用基础内容组件"><a href="#常用基础内容组件" class="headerlink" title="常用基础内容组件"></a>常用基础内容组件</h4><ol><li>text<ul><li>文本组件</li><li>类似于html中的span标签，是一个行内元素</li></ul></li><li>rich-text<ul><li>富文本组件</li><li>支持把html字符串渲染为wxml结构</li></ul></li></ol><h4 id="其他常用组件"><a href="#其他常用组件" class="headerlink" title="其他常用组件"></a>其他常用组件</h4><ol><li>button<ul><li>按钮组件</li><li>通过open-type属性调用微信提供的各种功能（客服、转发、获取用户权限、获取用户信息等）</li></ul></li><li>image<ul><li>图片组件</li><li>image组件默认宽度约300px、高度约240px</li></ul></li><li>navigator<ul><li>页面导航组件</li><li>类似于a链接</li></ul></li></ol><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>由宿主环境提供</p><h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><ol><li>事件监听API<ul><li>特点：<strong>以on开头</strong>，监听某些事件的触发</li><li>例如：wx.<strong>on</strong>WindowResize(function callback)监听窗口尺寸变化的事件</li></ul></li><li>同步API<ul><li><strong>以Sync结尾</strong>的API都是同步API</li><li>同步API的执行结果，可以通过函数返回值直接获取，如果执行出错就会抛出异常</li><li>例如：wx.setStorage<strong>Sync</strong>(‘key’,’value’)向本地存储中写入内容</li></ul></li><li>异步API<ul><li>类似于jQuery中的$.ajax(options)函数，需要<strong>通过success、fail、complete接收调用的结果</strong></li><li>例如：wx.request()发起网络数据请求，通过success回调函数接收数据</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 项目 </tag>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录-数组篇刷题记录</title>
      <link href="/2023/01/02/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%95%B0%E7%BB%84%E7%AF%87%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/01/02/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%95%B0%E7%BB%84%E7%AF%87%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例 1:</p><p>输入: nums = [-1,0,3,5,9,12], target = 9<br>输出: 4<br>解释: 9 出现在 nums 中并且下标为 4<br>示例 2:</p><p>输入: nums = [-1,0,3,5,9,12], target = 2<br>输出: -1<br>解释: 2 不存在 nums 中因此返回 -1</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/binary-search">https://leetcode.cn/problems/binary-search</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>很重要的是确定二分法的边界，这里采用的是<strong>左闭右闭</strong>方法，即<code>[left,right]</code>。利用while循环，设置条件为<code>left&lt;=right</code>。计算中间值<code>mid=(left+right)/2</code>，比较<code>mid</code>值与<code>target</code>值的大小关系。</p><p>如果<code>mid&lt;target</code>，那么说明目标值不会出现在<code>mid</code>值以及其左侧，故更新<code>left=mid+1</code>;<br>如果<code>mid&gt;target</code>，那么说明目标值不会出现在<code>mid</code>值以及其右侧，故更新<code>right=mid-1</code>。</p><h2 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左闭右闭型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">                r=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//左闭右开型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r=nums.length;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">                r=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h1><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><p> </p><p>示例 1:</p><p>输入: nums = [1,3,5,6], target = 5<br>输出: 2<br>示例 2:</p><p>输入: nums = [1,3,5,6], target = 2<br>输出: 1<br>示例 3:</p><p>输入: nums = [1,3,5,6], target = 7<br>输出: 4</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/search-insert-position">https://leetcode.cn/problems/search-insert-position</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>主要是自己想明白最后left的值是应该插入的位置索引</p><h3 id="具体代码-1"><a href="#具体代码-1" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">                r=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h1><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><p>// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝<br>int len = removeElement(nums, val);</p><p>// 在函数里修改输入数组对于调用者是可见的。<br>// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。<br>for (int i = 0; i &lt; len; i++) {<br>    print(nums[i]);<br>}</p><p>示例 1：</p><p>输入：nums = [3,2,2,3], val = 3<br>输出：2, nums = [2,2]<br>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。<br>示例 2：</p><p>输入：nums = [0,1,2,2,3,0,4,2], val = 2<br>输出：5, nums = [0,1,4,0,3]<br>解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/remove-element">https://leetcode.cn/problems/remove-element</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>暴力法：遍历数组找到val值，之后按位移动所在位之后的所有元素。记得更新i和len（因为已经移除了当前元素）</p><h3 id="具体代码-2"><a href="#具体代码-2" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==val)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">                    nums[j-<span class="number">1</span>]=nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                i--; <span class="comment">//因为当前位置被删除了，所以需要-1</span></span><br><span class="line">                len--; <span class="comment">//移除一个元素，长度-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h1><h1 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h1><h1 id="螺旋矩阵Ⅱ"><a href="#螺旋矩阵Ⅱ" class="headerlink" title="螺旋矩阵Ⅱ"></a>螺旋矩阵Ⅱ</h1>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 力扣刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode HOT 100 刷题记录</title>
      <link href="/2023/01/02/LeetCode-HOT-100-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/01/02/LeetCode-HOT-100-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-HOT-100-刷题记录"><a href="#LeetCode-HOT-100-刷题记录" class="headerlink" title="LeetCode HOT 100 刷题记录"></a>LeetCode HOT 100 刷题记录</h1><h2 id="【易】2023-1-2-两数之和"><a href="#【易】2023-1-2-两数之和" class="headerlink" title="【易】2023-1-2 两数之和"></a>【易】2023-1-2 两数之和</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>两个for循环遍历数组，依次判断两数之和是否等于target值。</p><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> pos[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line">                    pos[<span class="number">0</span>]=i;</span><br><span class="line">                    pos[<span class="number">1</span>]=j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="【中】2023-1-4-2两数相加"><a href="#【中】2023-1-4-2两数相加" class="headerlink" title="【中】2023-1-4 2两数相加"></a>【中】2023-1-4 2两数相加</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。<br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg"></p><p>示例 1：<br>输入：l1 = [2,4,3], l2 = [5,6,4]<br>输出：[7,0,8]<br>解释：342 + 465 = 807.</p><p>示例 2：<br>输入：l1 = [0], l2 = [0]<br>输出：[0]</p><p>示例 3：<br>输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]<br>输出：[8,9,9,9,0,0,0,1]<br> <br>提示：<br>每个链表中的节点数在范围 [1, 100] 内<br>0 &lt;= Node.val &lt;= 9<br>题目数据保证列表表示的数字不含前导零</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>建议这类题目自己动手画一下示意图效果更佳。已知题目中已经定义好了<code>ListNode</code>类和函数public <code>ListNode addTwoNumbers(ListNode l1, ListNode l2)</code></p><ol><li>创建一个表示结果的链表，定义头结点和尾结点</li><li>定义<code>carry</code>表示进位，等于0或1</li><li>循环遍历链表，只要其中之一不为空，可以一直循环<ul><li>初始化当前指针所指向的数值，要么为0要么等于具体数值<code>n1</code>和<code>n2</code>，并定义<code>sum=n1+n2+carry</code><ul><li>如果是链表中的第一个数，那么初始化结果链表，更新<code>head</code>和<code>tail</code>值</li><li>如果是链表中的第二个及其后的数，那么利用两数相加的和来创建新结点，并更新<code>tail</code></li></ul></li><li>更新进位制<code>carry</code></li><li>更新<code>l1</code>和<code>l2</code>的值</li></ul></li><li>退出循环，如果最后计算的那一位仍有进位，则再后移<code>tail</code>结点</li></ol><h3 id="具体代码-1"><a href="#具体代码-1" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="comment">//新创建一个表示结果的链表，头结点和尾结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>, tail = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//进位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> l1 != <span class="literal">null</span> ? l1.val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> l2 != <span class="literal">null</span> ? l2.val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> n1 + n2 + carry;</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果是第一个数，那么新建一个结点存储计算结果</span></span><br><span class="line">                head = tail = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//创建一个新结点 存放新的（sum）一位</span></span><br><span class="line">                tail.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">                tail = tail.next; <span class="comment">//尾结点向后移动</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新进位值</span></span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//更新l1、l2的值</span></span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最后计算的那一位仍有进位，则再新建一个结点来记录</span></span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            tail.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 力扣刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apache服务器基于用户的访问控制</title>
      <link href="/2022/12/16/Apache%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E4%BA%8E%E7%94%A8%E6%88%B7%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"/>
      <url>/2022/12/16/Apache%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E4%BA%8E%E7%94%A8%E6%88%B7%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>为万维网服务器创建<strong>首个</strong>用户时使用命令：<code>htpasswd -c /etc/httpd/htpasswd tux</code><br>还要创建其他用户时，使用命令：<code>htpasswd2 /etc/httpd/htpasswd username</code><br>**WARNING:创建首个用户之后不能再用<code>htpasswd -c </code>，因为会覆盖掉之前的用户。</p>]]></content>
      
      
      <categories>
          
          <category> 实验 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chcon can&#39;t apply partial context to unlabeled file varwwwtemp报错</title>
      <link href="/2022/12/16/chcon%20can&#39;t%20apply%20partial%20context%20to%20unlabeled%20file%20varwwwtemp%E6%8A%A5%E9%94%99/"/>
      <url>/2022/12/16/chcon%20can&#39;t%20apply%20partial%20context%20to%20unlabeled%20file%20varwwwtemp%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<p>命令：<code>chcon -R -t httpd_sys_content_t /var/www/temp</code><br>报错内容：<code>chcon: can&#39;t apply partial context to unlabeled file /var/www/temp</code></p><p>解决方法：修改/etc/selinux/config</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># This file controls the state of SELinux on the system.</span><br><span class="line"># SELINUX= can take one of these three values:</span><br><span class="line">#       enforcing - SELinux security policy is enforced.</span><br><span class="line">#       permissive - SELinux prints warnings instead of enforcing.</span><br><span class="line">#       disabled - SELinux is fully disabled.</span><br><span class="line">SELINUX=disabled</span><br><span class="line"># SELINUXTYPE= type of policy in use. Possible values are:</span><br><span class="line">#       targeted - Only targeted network daemons are protected.</span><br><span class="line">#       strict - Full SELinux protection.</span><br><span class="line">SELINUXTYPE=targeted</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>修改内容<code>SELINUX=disabled</code>为<code>SELINUX=enforcing</code></strong></p><p>重启服务器reboot，然后重新启动httpd服务，再次执行命令就OK了。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Linus </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常见问题 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUnit的使用</title>
      <link href="/2022/11/05/JUnit%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/11/05/JUnit%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OSmooc题目整理</title>
      <link href="/2022/10/13/OSmooc%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/"/>
      <url>/2022/10/13/OSmooc%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章单元测试"><a href="#第一章单元测试" class="headerlink" title="第一章单元测试"></a>第一章单元测试</h1><p>1.操作系统是对（ A）进行管理的软件。</p><p>A.计算机资源</p><p>B.软件</p><p>C.硬件</p><p>D.应用程序</p><p>2.操作系统是一种（ C）。</p><p>A.应用软件</p><p>B.通用软件</p><p>C.系统软件</p><p>D.软件</p><p>3下列选项中，不属于多道程序设计的基本特征是（ D）</p><p>A.间断性</p><p>B.多道性</p><p>C.无序性</p><p>D.顺序性</p><p>4.提高CPU利用率的关键技术是（C ）</p><p>A.脱机技术</p><p>B.交换技术</p><p>C.多道程序设计技术</p><p>D.虚拟技术</p><p>5分时系统追求的目标是（ A）</p><p>A.快速响应用户</p><p>B.充分利用I/O设备</p><p>C.充分利用内存</p><p>D.提高系统吞吐率</p><h1 id="第二章单元测试"><a href="#第二章单元测试" class="headerlink" title="第二章单元测试"></a>第二章单元测试</h1><p>1.处理器执行的指令被分为两类，其中有一类称为特权指令，它只允许（C ）使用</p><p>A.联机用户</p><p>B.操作员</p><p>C.操作系统</p><p>D.目标程序</p><p>2.当CPU执行操作系统代码时，处理器处于（B）</p><p>A.用户态</p><p>B.核心态</p><p>C.就绪态</p><p>D.自由态</p><p>3.操作系统提供给编程人员的接口是（ C）</p><p>A.高级语言</p><p>B.库函数</p><p>C.系统调用</p><p>D.子程序</p><p>4.在中断发生后，进入中断处理的程序属于（ C）</p><p>A.可能是应用程序，也可能是操作系统程序</p><p>B.既不是应用程序，也不是操作系统程序</p><p>C.操作系统程序</p><p>D.用户程序</p><p>5.下列必须在核心态下执行的指令是（B ）</p><p>A.从内存中取数</p><p>B.I/O操作</p><p>C.将运算结果装入内存</p><p>D.算术运算</p><h1 id="第三章单元测试"><a href="#第三章单元测试" class="headerlink" title="第三章单元测试"></a>第三章单元测试</h1><p>1.一个进程是（C）。</p><p>A.由协处理器执行的一个程序</p><p>B.一个独立的程序+数据集</p><p>C.PCB结构与程序和数据的组合</p><p>D.一个独立的程序</p><p>2.进程与程序的根本区别是（C）。</p><p>A.是不是占有处理器</p><p>B.是不是被调入到内存</p><p>C.静态和动态的区别</p><p>D.是不是具有就绪、运行和等待三种状态</p><p>3.操作系统是根据（C）来对并发执行的进程进行控制和管理的。</p><p>A.多道程序设计</p><p>B.进程的基本状态</p><p>C.进程控制块</p><p>D.进程的优先权</p><p>4下列几种关于进程的叙述，（D）是最不符合操作系统对进程的理解。</p><p>A.进程是程序在一个数据集合上的运行过程</p><p>B.进程可以由程序、数据和PCB描述</p><p>C.进程是系统进行资源分配和调度的一个独立单元</p><p>D.进程是在多程序环境中的完整的程序</p><p>5.同一程序经过多次创建，运行在不同的数据集上，形成了（C）的进程。</p><p>A.互斥</p><p>B.相同</p><p>C.不同</p><p>D.同步</p><p>6.用信箱实现进程间互通消息的通信机制要有两个通信原语，它们是（A）。</p><p>A.发送原语和接收原语</p><p>B.就绪原语和执行原语</p><p>C.发送原语和执行原语</p><p>D.就绪原语和接收原语</p><p>7.当（D）时，进程从执行状态转变为就绪状态。</p><p>A.进程被调度程序选中</p><p>B.等待某一事件</p><p>C.等待的事件发生</p><p>D.时间片到</p><p>8.进程创建后，所有创建完成的PCB被链接成一个序列，这个序列称为（C）。</p><p>A.作业队列</p><p>B.阻塞队列</p><p>C.就绪队列</p><p>D.运行队列</p><p>9.长（作业）调度程序控制（D ）。</p><p>A.进程执行的时间</p><p>B.等待队列中进程的个数</p><p>C.就绪进程的个数</p><p>D.多道程序的道</p><p>10.在单处理器系统中，如果同时存在10个进程，则处于就绪队列中的进程最多有（A）个。</p><p>A.9</p><p>B.1</p><p>C.8</p><p>D.10</p><p>11判断(2分)<br>一个进程的状态变化一定会引起另一个进程的状态变化。<br>×错</p><p>12判断(2分)<br>一个进程等待的I/O操作完成后，进程状态将会从阻塞变为就绪。<br>对√</p><p>13判断(2分)<br>执行fork系统调用时，子进程会复制父进程的地址空间。<br>对√</p><p>14判断(2分)<br>与其他进程共享数据的进程是协作进程。<br>对√</p><p>15判断(2分)<br>短调度是指从作业队列中选择作业并装入内存。<br>错×<br>.</p><h1 id="第四章单元测试"><a href="#第四章单元测试" class="headerlink" title="第四章单元测试"></a>第四章单元测试</h1><p>1.若某一进程拥有100个线程，这些线程都属于用户级线程，则每一个线程在系统调度时间上占用的时间片是（想知道答案，请留言、点赞、并私聊 ）。</p><p>A.1</p><p>B.0</p><p>C.100</p><p>D.1/100</p><p>2.在多对一的线程模型中，当一个多线程进程的某个线程被阻塞后（C）。</p><p>A.该阻塞线程将永远不可能在执行</p><p>B.该阻塞线程将被撤销</p><p>C.整个进程都将被阻塞</p><p>D.该进程的其他线程仍可继续运行</p><p>3.下面的叙述中，正确的是（D）。</p><p>A.同一进程或不同进程内的线程都只能串行执行</p><p>B.同一进程内的线程可并发执行，不同进程的线程只能串行执行</p><p>C.同一进程内的线程只能串行执行，不同进程的线程可并发执行</p><p>D.同一进程或不同进程内的线程都可以并发执行</p><p>4.下面说法正确的是（B）。</p><p>A.不论是系统支持的线程还是用户级线程，其切换都需要内核的支持</p><p>B.不管系统中是否有线程，进程都是拥有资源的独立单位</p><p>C.在引入线程的系统中，进程仍是资源调度和分派的基本单位</p><p>D.线程是资源分配的单位，进程是调度和分派的单位</p><p>5.引入线程的主要目的是（B ）。</p><p>A.执行更多任务</p><p>B.提高并发程度同时降低开销</p><p>C.加快运算速度</p><p>D.实现资源共享</p><p>6.线程也具有就绪、阻塞和运行三种基本状态。<br>对√</p><p>7.CPU调度时，时间片是分给用户线程的。<br>错×</p><p>8.多对一模型的缺点是不能实现真正的并发。<br>对√</p><p>9.用户线程是在用户空间管理的，内核也能感知。<br>错×</p><p>10.同一个进程内的多个线程之间共享进程的资源。<br>对√</p><h1 id="第五章单元测试"><a href="#第五章单元测试" class="headerlink" title="第五章单元测试"></a>第五章单元测试</h1><p>1.在单处理器的多进程系统中，进程什么时候占用处理器以及决定占用时间的长短是由（B）决定的。</p><p>A.进程相应的代码长度</p><p>B.进程特点和进程调度策略</p><p>C.进程总共需要运行的时间</p><p>D.进程完成什么功能</p><p>2.（C ）有利于CPU繁忙型的作业，而不利于I/O繁忙型的作业。</p><p>A.时间片轮转调度算法</p><p>B.短作业（进程）优先算法</p><p>C.先来先服务调度算法</p><p>D.优先权调度算法</p><p>3.时间片轮转调度算法是为了（D）。</p><p>A.使系统变得高效</p><p>B.需要CPU时间最少的进程最先做</p><p>C.优先级较高的进程得到及时响应</p><p>D.多个终端能够得到系统及时响应</p><p>4.（A）优先级是在创建进程时确定的，确定之后在整个运行期间不再改变。</p><p>A.静态</p><p>B.动态</p><p>C.先来先服务</p><p>D.短作业</p><p>5.采用时间片轮转调度算法分配CPU时，当处于运行状态的进程用完一个时间片后，他的状态是（C ）状态。</p><p>A.运行</p><p>B.消亡</p><p>C.就绪</p><p>D.阻塞</p><p>6.下列调度算法中，（B）调度算法是绝对可抢占的。</p><p>A.优先级</p><p>B.时间片轮转</p><p>C.短进程优先</p><p>D.先来先服务</p><p>7.下列选项中，降低进程优先级的合理时机是（D）。</p><p>A.进程刚完成I/O操作，进入就绪队列</p><p>B.进程从就绪状态转为运行状态</p><p>C.进程长期处于就绪队列</p><p>D.进程时间片用完</p><p>8.设有4个作业同时到达，每个作业的执行时间均为2h，它们在一台处理器上技单道式运行，则平均周转时间为（D）。</p><p>A.8h</p><p>B.1h</p><p>C.2.5h</p><p>D.5h</p><p>4*2+2+4+6=20 20/4=5h</p><p>9.假设系统中所有的进程都是同时到达，则使进程平均等待时间最短的是（ C）调度算法。</p><p>A.时间片轮转</p><p>B.先来先服务</p><p>C.短作业优先</p><p>D.优先级</p><p>10.下面关于选择进程调度算法的准则中不正确的是（B ）。</p><p>A.尽快响应交互式用户的请求</p><p>B.适当增加进程在就绪队列的等待时间</p><p>C.尽量提高CPU利用率</p><p>D.尽可能提高系统的吞吐量</p><h1 id="第六章单元测试"><a href="#第六章单元测试" class="headerlink" title="第六章单元测试"></a>第六章单元测试</h1><p>1.下列对临界区的论述中，正确的是（ A）。</p><p>A.临界区是指进程中用于访问共享资源的那段代码</p><p>B.临界区是指进程中用于实现进程互斥的那段代码</p><p>C.临界区是指进程中用于实现进程同步的那段代码</p><p>D.临界区是指进程中用于实现进程通信的那段代码</p><p>2.若一个信号量的初值为3，经过多次PV操作以后当前值为－1，此表示等待进入临界区的进程数是（ C ）。</p><p>A.3</p><p>B.4</p><p>C.1</p><p>D.2</p><p>*3.设与某资源关联的信号量（K）初值为3，当前值为1。若M表示该资源的可用个数，N表示等待该资源的进程数，则M、N分别是（B）。</p><p>A.0、1</p><p>B.1、0</p><p>C.2、0</p><p>D.1、2</p><p>4.P操作可能导致（D）。</p><p>A.进程结束</p><p>B.进程就绪</p><p>C.新进程创建</p><p>D.进程阻塞</p><p>5.用V操作唤醒一个等待进程时，被唤醒进程的变为（D）状态。</p><p>A.运行</p><p>B.等待</p><p>C.完成</p><p>D.就绪</p><p>6.在用信号量机制实现互斥时，互斥信号量的初值为（A）。</p><p>A.1</p><p>B.2</p><p>C.3</p><p>D.0</p><p>7.有三个进程共享同一程序段，而每次只允许两个进程进入该程序段，若用PV操作同步机制，则信号量S的取值范围是（A）。</p><p>A.2，1，0，-1</p><p>B.1，0，-1，-2</p><p>C.3，2，1，0</p><p>D.2，1，0，-1，-2</p><p>8.对于两个并发进程，设互斥信号量为 mutex（初值为1），若 mutex＝0，则（B）。</p><p>A.表示有一个进程进入临界区，另一个进程等待进入</p><p>B.表示有一个进程进入临界区</p><p>C.表示有两个进程进入临界区</p><p>D.表示没有进程进入临界区</p><p>9.在操作系统中，要对并发进程进行同步的原因是（ C ）。</p><p>A.进程具有动态性</p><p>B.进程必须在有限的时间内完成</p><p>C.并发进程是异步的</p><p>D.进程具有结构性</p><p>10.在操作系统中，要对并发进程进行同步的原因是（ B ）。</p><p>A.进程具有动态性</p><p>B.并发进程是异步的</p><p>C.进程具有结构性</p><p>D.进程必须在有限的时间内完成</p><p>11判断(2分)<br>临界区就是临界资源所在的区域。<br>错×</p><p>12判断(2分)<br>信号量是一个整型变量，可以直接对其进行加1和减1的操作。<br>错×<br>*必须先进行判断</p><p>13判断(2分)<br>V操作表示申请一个资源。<br>错×</p><p>14判断(2分)<br>一个正在访问临界资源的进程因为申请I/O操作而阻塞时，它允许其他进程进入其临界区。<br>错×</p><p>15判断(2分)<br>PV操作是原子操作。<br>对√</p><h2 id="第七章-死锁"><a href="#第七章-死锁" class="headerlink" title="第七章 死锁"></a>第七章 死锁</h2><p>1.​下列情况可能导致死锁的是（ A ）。</p><p>A.多个进程竟争资源出现了循环等待</p><p>B.一个进程进入死循环</p><p>C.多个进程竞争使用共享型的设备</p><p>D.进程释放资源</p><p>2.‍在操作系统中，死锁出现是指（ A ）。</p><p>A.若干进程因竟争资源而无限等待其他进程释放已占有的资源</p><p>B.进程同时申请的资源数超过资源总数</p><p>C.计算机系统发生重大故障</p><p>D.资源个数远远小于进程数</p><p>3.‌一次分配所有资源的方法可以预防死锁的发生，它破坏的死四个必要条件中的（ A）。</p><p>A.请求并保持</p><p>B.互斥</p><p>C.环路等待</p><p>D.非剩夺</p><p>4.死锁的避免是根据（ B ）采取措施实现的。</p><p>A.使进程的推进顺序合理</p><p>B.防止系统进入不安全状态</p><p>C.配置足够的系统资源</p><p>D.破坏死锁的四个必要条件之一</p><p>5.以下有关资源分配图的描述中正确的是（ D ）。</p><p>A.有向边包括进程指向资源类的分配边和资源类指向进程申请边两类</p><p>B.圆圈节点表示资源类</p><p>C.矩形框表示进程，其中圆点表示申请同一类资源的各个进程</p><p>D.资源分配图是一个有向图，用于表示某时刻系统资源与进程之间的状态</p><p>6.‌死锁与安全状态的关系是（ C ）。</p><p>A.安全状态有可能成为死锁状态</p><p>B.不安全状态就是死锁状态</p><p>C.死锁状态一定是不安全状态</p><p>D.死锁状态有可能是安全状态</p><p>解析：  C、死锁状态肯定不安全，不安全状态不一定死锁。</p><p>7.​在下列死锁的解决方法中，属于死锁避免策略的是（ C ）。</p><p>A.死锁检测算法</p><p>B.破坏不可剥夺条件</p><p>C.银行家算法</p><p>D.资源有序分配算法</p><p>8.‍解除死锁通常不采用的方法是（ C ）。</p><p>A.从死锁进程处抢夺资源</p><p>B.从非死锁进程处抢夺资源</p><p>C.终止所有死锁进程</p><p>D.终止一个死锁进程</p><p>正确答案：C你错选为B</p><p>9.死锁的四个必要条件中，无法破坏的是（ C ）。</p><p>A.环路等待</p><p>B.请求并保持</p><p>C.互斥</p><p>D.非剥夺</p><p>*10.某系统中有三个并发进程都需要四个同类资源，该系统不会发生死锁的最少资源是（ D ）。</p><p>A.11</p><p>B.12</p><p>C.9</p><p>D.10</p><p>解析：  B、（4-1）*3+1=10</p><p>11判断(2分)<br>​死锁避免是通过打破死锁的必要条件实现的。 F</p><p>解析：<strong>死锁预防</strong>是通过打破死锁的必要条件实现的。</p><p>12判断(2分)<br>​产生死锁的根本原因是资源竞争和进程推进顺序非法。 T</p><p>13判断(2分)<br>采用资源剥夺可以解除死锁，还可以采用终止进程的方法解除死锁。 T</p><p>14判断(2分)<br>资源分配图中出现环路，则一定会死锁。 F<br>解析：资源分配图中资源有<strong>多个实例</strong>时，出现环路不一定会死锁。</p><p>15判断(2分)<br>​为了避免死锁的发生，各进程应该按序逐个申请资源。 F</p><h2 id="第九章-虚拟内存"><a href="#第九章-虚拟内存" class="headerlink" title="第九章 虚拟内存"></a>第九章 虚拟内存</h2><p>简单分页和虚拟分页的区别？<br>简单分页:一个程序中的所有的页都必须在主存储器中程序才能正常运行，除非使用覆盖技术。<br>虚拟内存分页:不是程序的每一页都必须在主存储器的帧中来使程序运行，页在需要的时候进行读取。</p><p>虚拟存储管理系统的基础是程序的局部性理论 。</p><p>实现虚拟存储器的目的是扩充主存的容量最主要的技术是部分对换。</p><p>进程执行发生缺页中断，经操作系统处理后，应执行被中断的那一条指令。</p><p>虚拟内存特性：离散性、多次性、对换性、虚拟性。</p><p>若虚拟内存系统能有效发挥作用，则程序应具有的特征是——程序具有较好的局部性。</p><p>在请求分页系统中，不能组合使用的页面分配策略与页面置换策略是——固定分配、全局置换。</p><p>分页请求系统<br>硬件支持：1）请求分页的<strong>页表</strong>机制；2）<strong>缺页</strong>中断机构；3）地址变换机构。</p><p>请求分段系统<br>硬件支持：1）请求分段的<strong>段表</strong>机制；2）<strong>缺段</strong>中断机构；3）地址变换机构。</p><ol><li><p>下列关于常规存储器的论述中，正确的论述是( C )。<br>A. 作业在运行前，不必全部装入内存，且在运行过程中也不必一直驻留内存<br>B. 作业在运行前，不必全部装入内存，但在运行过程中必须一直驻留内存<br>C.作业在运行前，必须全部装入内存，且在运行过程中也一直驻留内存<br>D.作业在运行前，必须全部装入内存，但在运行过程中不必一直驻留内存<br>解析:常规存储管理具有一 次性和驻留性。</p></li><li><p>为使虚存系统有效地发挥其预期的作用，所运行的程序应具有的特性是（C）。</p></li></ol><p>A.该程序的大小不应超过实际的内存容量</p><p>B.该程序不应含有过多的I/O操作</p><p>C.该程序应具有较好的局部性</p><p>D.该程序的指令相关性不应过多</p><ol start="3"><li>( D )是请求分页存储管理方式和基本分页存储管理方式的区别。</li></ol><p>A. 不必将作业装入连续区域</p><p>B.采用快表技术</p><p>C.地址重定向</p><p>D. 不必将作业全部装入内存</p><ol start="4"><li>虚拟存储管理系统的基础是程序的( B ) 理论。</li></ol><p>A. 全局性</p><p>B.局部性</p><p>C. 虚拟性</p><p>D. 动态性</p><ol start="5"><li>在虚拟分页存储管理系统中，若进程访间的页面不在主存，且主存中没有可用的空闲帧时，系统正确的处理顺序为( B )</li></ol><p>A.缺页中断→决定淘汰页→页面调入→页面调出</p><p>B. 缺页中断→決定淘汰页→页面调出→页面调入</p><p>C. 決定淘汰页一页面调出→缺页中断→页面调入</p><p>D.决定淘汰页→页面调入→缺页中断→页面调出</p><ol start="6"><li>进程在执行中发生了缺页中断，经操作系统处理后，应让其执行( C ) 指令。</li></ol><p>A.被中断的后一条</p><p>B.启动时的那一条</p><p>C.被中断的那一条</p><p>D.被中断的前一-条</p><p>解析: 缺页中断处理后，将要访问的页调入内存，此时被中断的指令要再次执行。</p><ol start="7"><li>考虑页面置换算法，系统有m个物理块供调度， 初始时全空，页面引用串长度为p，包含了n个不同的页号，无论用什么算法，缺页次数不会少于( B )。</li></ol><p>A.m</p><p>B.n</p><p>C.min(m,n)</p><p>D.p</p><p>解析: 无论采用哪种页面置换算法，每个页第一次被访问时都会缺页， 所以页次数至少是n</p><ol start="8"><li>当系统发生抖动( Thrashing) 时，可用采取的有效措施是( C )。</li></ol><p>A. 提高用户进程的优先级</p><p>B.以上都对</p><p>C. 撤销部分进程</p><p>D. 增加磁盘交换区的容量</p><ol start="9"><li>页式虚拟存储管理的主要特点是( C )。</li></ol><p>A. 不要求将作业装入到主存的连续区域</p><p>B. 不要求进行缺页中断处理</p><p>C. 不要求将作业同时全部装入到主存的连续区域</p><p>D. 不要求进行页面置换</p><ol start="10"><li>某虚拟存储器系统采用分页内存管理和最长时间未使用页面淘汰算法(LRU)，考虑下面的页面访问地址序列: 1 8 1 7 8 2 7 2 1 8 3 8 2 1 3 1 7 1 3 7假定分配给某进程4个内存页面且开始时全部空闲(空白)，则发生缺页的次数是( B )。</li></ol><p>A.4</p><p>B.6</p><p>C.5</p><p>D. 7</p><ol start="11"><li><p>缺页中断是在指令执行期间产生和处理中断信号,而非一条指令执行之后。对</p></li><li><p>‍抖动是指进程频繁进行页面置换。在换页上的时间多于进程执行的时间。 对</p></li><li><p>‌时间局部性是指，当程序访问了某个存储单元，在不久之后，其附近的存储单元也会被访问。错 这是空间局部性</p></li><li><p>虚拟存储器的最大容量是任意的。错</p></li><li><p>在进程运行时，如果它的工作集页面都在虚拟存储器内，能够使该进程有效的运行，‌否则会出现频繁的页面调入调出现象。 错 </p></li></ol><p>解析:在进程运行时，如果它的工作集页面都在<strong>内存</strong>中，能够使该进程有效的运行，否则会出现频繁的页面调入调出现象</p><p>在请求分页存管理的页表中增加了若干项信息，其中修改位和访间位供( B )参考。<br>A.分配页面<br>B.置换算法<br>C.调入页面<br>D. 程序访问</p><p>系统产生抖动主要原因是( B ) 。<br>A. CPU调度算法不合理<br>B.页面置换算法不合理<br>C. CPU运行速度太慢<br>D. 内存空间太小.</p><p>无论何时想要提高CPU的利用率, 都应该增加多道程序的道。<br>A. X<br>B. √<br>解析:当抖动时，需要降低多道程序的道。</p><p>时间局部性是指，当程序访问了某个存储单元，在不久之后，其附近的存储元也会被访问。<br>A. X<br>B. √<br>解析:空间局部性是指，当程序访问了某个存储单元，在不久之后，其附近的存储单元也会被访问。</p><p>虚拟存储器的最大容量是任意的。<br>A. X<br>B. √<br>解析:虚拟存储器的最大容量由计算机的地址结构决定</p><p>某请求分页系统采用先进先出页面淘汰算法，假定一个进程的页面引用序列为1、2、3、2、1、4、3、5、4、3、2、1、5，当分配给该进程的物理块数为3且未采用预调页策略时，该进程执行过程中所发生的缺页次数是( A )<br>A.7<br>B.6<br>C.8<br>D.5</p><p>系统采用改进时钟式页面淘汰算法，页表项中字段A为访问位，M为修改位。A=0表示页面没有被访问，A=1表示页面最近被访问过。M=0表示页面没有被修改过，M=1表示页面被修改过。根据&lt;A,M&gt;所有可能取值，将页面分为四类: &lt;0,0&gt;、 &lt;1,0&gt;、&lt;0,1&gt;和&lt;1,1&gt;,则该算法淘汰页面的优先次序从高到低为( B )。<br>A. &lt;0,0&gt;, &lt;1,1&gt;, &lt;0,1&gt;， &lt;1,0&gt;<br>B. &lt;0,0&gt;， &lt;0,1&gt;， &lt;1,0&gt;，&lt;1,1&gt;<br>C. &lt;0,0&gt;，&lt;0,1&gt;, &lt;1,1&gt;, &lt;1,0&gt;<br>D. &lt;0,0&gt;, &lt;1,0&gt;, &lt;0,1&gt;, &lt;1,1&gt;</p><p>关于请求分页系统的页面淘汰算法，下面说法错误的是( A ) 。<br>A. 时钟式页面淘汰算法首先调出最近一段时间内被访问次数最多的页面<br>B.最长时间未使用页面淘汰算法(LRU) 是基于局部性原理的一种算法，首先调出最近一段时间内最长时间未被访问过的页面<br>C.一个好的页面淘汰算法应尽量减少和避免抖动现象<br>D.进先出页面淘汰算法实现简单，选择最先进入主存储器的页面调出</p><p>在页面置换算法中，常利用( B ) 去评价其他算法。<br>A.先进先出置换算法<br>B.最佳置换算法<br>C. Clock置换算法<br>D.最近最久未使用置换算法</p><p>在请求分页存储管理中，若采用FIFO页面置换算法，则当分配的页面数增加时，缺页中断的次数( B )。<br>A.增加<br>B.可能增加也可能减少<br>C.无影响<br>D.减少</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Numpy学习笔记</title>
      <link href="/2022/10/09/Numpy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/10/09/Numpy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>与大多数语言一样，Python有许多基本类型，包括整数，浮点数，布尔值和字符串。这些数据类型的行为方式与其他编程语言相似。</p><h3 id="Numbers-数字类型"><a href="#Numbers-数字类型" class="headerlink" title="Numbers(数字类型)"></a>Numbers(数字类型)</h3><p>代表的是整数和浮点数，它原理与其他语言相同：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=<span class="number">3</span> </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(x)) <span class="comment">#&lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(x) <span class="comment">#3</span></span><br><span class="line"><span class="built_in">print</span>(x+<span class="number">1</span>) <span class="comment">#4</span></span><br><span class="line"><span class="built_in">print</span>(x-<span class="number">1</span>) <span class="comment">#2</span></span><br><span class="line"><span class="built_in">print</span>(x*<span class="number">2</span>) <span class="comment">#6</span></span><br><span class="line"><span class="built_in">print</span>(x**<span class="number">2</span>) <span class="comment">#9</span></span><br><span class="line">x+=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(x) <span class="comment">#4</span></span><br><span class="line">x*=<span class="number">2</span> </span><br><span class="line"><span class="built_in">print</span>(x) <span class="comment">#8</span></span><br><span class="line">y=<span class="number">2.5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(y)) <span class="comment">#&lt;class &#x27;float&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(y,y+<span class="number">1</span>,y*<span class="number">2</span>,y**<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="Booleans-布尔类型"><a href="#Booleans-布尔类型" class="headerlink" title="Booleans(布尔类型)"></a>Booleans(布尔类型)</h3><p>Python实现了所有常用的布尔逻辑运算符，但它使用的是英文单词而不是符号 (&amp;&amp;, ||, etc.)：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = <span class="literal">True</span></span><br><span class="line">f = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t))  <span class="comment">#&lt;class &#x27;bool&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(t <span class="keyword">and</span> f) <span class="comment">#False</span></span><br><span class="line"><span class="built_in">print</span>(t <span class="keyword">or</span> f) <span class="comment">#True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> t) <span class="comment">#False</span></span><br><span class="line"><span class="built_in">print</span>(t!=f) <span class="comment">#True</span></span><br></pre></td></tr></table></figure><h3 id="Strings-字符串类型"><a href="#Strings-字符串类型" class="headerlink" title="Strings(字符串类型)"></a>Strings(字符串类型)</h3><p>Python对字符串有很好的支持：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hello = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">world = <span class="string">&quot;world&quot;</span> <span class="comment"># 双引或单引号都可以</span></span><br><span class="line"><span class="built_in">print</span>(hello) </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(hello)) <span class="comment"># 长度5</span></span><br><span class="line">hw = hello + <span class="string">&#x27; &#x27;</span> +world <span class="comment">#字符串连接</span></span><br><span class="line"><span class="built_in">print</span>(hw)</span><br><span class="line">hw12 = <span class="string">&#x27;%s %s %d&#x27;</span> % (hello,world,<span class="number">12</span>)</span><br><span class="line"><span class="built_in">print</span>(hw12)</span><br></pre></td></tr></table></figure><p>还有很多其他方法:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=<span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.capitalize()) <span class="comment">#Hello 首字母大写</span></span><br><span class="line"><span class="built_in">print</span>(s.upper()) <span class="comment">#变大写</span></span><br><span class="line"><span class="built_in">print</span>(s.rjust(<span class="number">7</span>)) <span class="comment">#左填充空格</span></span><br><span class="line"><span class="built_in">print</span>(s.center(<span class="number">7</span>)) <span class="comment">#填充使得字符串在中心</span></span><br><span class="line"><span class="built_in">print</span>(s.replace(<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;(ell)&#x27;</span>)) <span class="comment">#替换l为ell</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;  world&#x27;</span>.strip()) <span class="comment">#移除字符串头尾指定的字符</span></span><br><span class="line">                        <span class="comment">#（默认为空格或换行符）或字符序列</span></span><br></pre></td></tr></table></figure><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>Python包含几种内置的容器类型：列表、字典、集合和元组。</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表其实就是Python中的数组，但是它可以动态的调整大小并且可以包含不同类型的元素。</p><ul><li>第一个索引是0，第二个索引是1，依此类推。</li><li>Python有6个序列的内置类型，但最常见的是列表和元组。</li><li>序列都可以进行的操作包括索引，切片，加，乘，检查成员。</li><li>列表的数据项<strong>不需要具有相同的类型</strong>。</li></ul><p>创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1=[<span class="string">&#x27;ph&#x27;</span>,<span class="string">&#x27;stu&#x27;</span>,<span class="number">1988</span>,<span class="number">2022</span>]</span><br><span class="line">list2=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">list3=[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>]</span><br></pre></td></tr></table></figure><h3 id="访问列表中的值"><a href="#访问列表中的值" class="headerlink" title="访问列表中的值"></a>访问列表中的值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1=[<span class="string">&#x27;ab&#x27;</span>,<span class="string">&#x27;cd&#x27;</span>,<span class="number">123</span>,<span class="number">456</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;list1[0]:&quot;</span>,list1[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(list1[<span class="number">1</span>:<span class="number">5</span>])</span><br></pre></td></tr></table></figure><h3 id="更新列表"><a href="#更新列表" class="headerlink" title="更新列表"></a>更新列表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>=[]</span><br><span class="line"><span class="built_in">list</span>.append(<span class="string">&#x27;stu&#x27;</span>)</span><br><span class="line"><span class="built_in">list</span>.append(<span class="string">&#x27;net&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="comment"># [&#x27;stu&#x27;, &#x27;net&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="删除列表元素"><a href="#删除列表元素" class="headerlink" title="删除列表元素"></a>删除列表元素</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1=[<span class="string">&#x27;ab&#x27;</span>,<span class="string">&#x27;cd&#x27;</span>,<span class="number">123</span>,<span class="number">456</span>]</span><br><span class="line"><span class="built_in">print</span>(list1)</span><br><span class="line"><span class="keyword">del</span> list1[<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(list1)</span><br><span class="line"><span class="comment">#[&#x27;ab&#x27;, &#x27;cd&#x27;, 123, 456]</span></span><br><span class="line"><span class="comment">#[&#x27;ab&#x27;, &#x27;cd&#x27;, 456]</span></span><br></pre></td></tr></table></figure><h3 id="脚本操作符"><a href="#脚本操作符" class="headerlink" title="脚本操作符"></a>脚本操作符</h3><p>列表对+和* 的操作符与字符串相似。+号用于组合列表* 号用于重复列表。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">#3 #长度</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]+[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>] <span class="comment">#[1,2,3,4,5,6] #组合</span></span><br><span class="line">[<span class="string">&#x27;Hi&#x27;</span>]*<span class="number">4</span> <span class="comment">#[&#x27;Hi&#x27;,&#x27;Hi&#x27;,&#x27;Hi&#x27;,&#x27;Hi&#x27;] #重复</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">#True #元素是否位于列表中</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]:  <span class="comment">#1 2 3 #迭代</span></span><br><span class="line">    <span class="built_in">print</span>(x)   </span><br></pre></td></tr></table></figure><h3 id="列表截取"><a href="#列表截取" class="headerlink" title="列表截取"></a>列表截取</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l=[<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;three&#x27;</span>,<span class="string">&#x27;four&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(l[<span class="number">2</span>]) <span class="comment">#three</span></span><br><span class="line"><span class="built_in">print</span>(l[-<span class="number">1</span>]) <span class="comment">#four</span></span><br><span class="line"><span class="built_in">print</span>(l[<span class="number">1</span>:]) <span class="comment">#[&#x27;two&#x27;, &#x27;three&#x27;, &#x27;four&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="列表函数-amp-方法"><a href="#列表函数-amp-方法" class="headerlink" title="列表函数&amp;方法"></a>列表函数&amp;方法</h3><ol><li>**cmp(list1, list2)**【比较两个列表的元素】</li><li>**len(list)**【列表元素个数】</li><li>**max(list)**【返回列表元素最大值】</li><li>**min(list)**【返回列表元素最小值】</li><li>**list(swq)**【将元组转换为列表】</li><li>**list.append(obj)**【在列表末尾添加新的对象】</li><li>**list.count(obj)**【统计某个元素在列表中出现的次数】</li><li>**list.extend(seq)**【在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）】</li><li>**list.index(obj)**【从列表中找出某个值第一个匹配项的索引位置】</li><li>**list.insert(index, obj)**【将对象插入列表】</li><li>**list.pop([index=-1])**【移除列表中的一个元素（默认最后一个元素），并且返回该元素的值】</li><li>**list.remove(obj)**【移除列表中某个值的第一个匹配项】</li><li>**list.reverse()**【反向列表中元素】</li><li>**list.sort(cmp=None, key=None, reverse=False)**【对原列表进行排序】</li></ol><p>以下是常用操作的集合。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xs = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(xs,xs[<span class="number">2</span>]) <span class="comment">#[3, 1, 2] 2</span></span><br><span class="line"><span class="built_in">print</span>(xs[-<span class="number">1</span>]) <span class="comment">#2</span></span><br><span class="line"><span class="built_in">print</span>(xs[-<span class="number">2</span>]) <span class="comment">#1</span></span><br><span class="line">xs[<span class="number">2</span>]=<span class="string">&#x27;foo&#x27;</span> <span class="comment">#列表中可以放不同类型的元素</span></span><br><span class="line"><span class="built_in">print</span>(xs) <span class="comment">#[3, 1, &#x27;foo&#x27;]</span></span><br><span class="line">xs.append(<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(xs) <span class="comment">#[3, 1, &#x27;foo&#x27;, &#x27;bar&#x27;]</span></span><br><span class="line">x = xs.pop()</span><br><span class="line"><span class="built_in">print</span>(x) <span class="comment">#bar</span></span><br><span class="line"><span class="built_in">print</span>(xs)  <span class="comment">#[3, 1, &#x27;foo&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(x,xs) <span class="comment"># bar [3, 1, &#x27;foo&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="切片-Slicing"><a href="#切片-Slicing" class="headerlink" title="切片(Slicing)"></a>切片(Slicing)</h4><p>除了一次访问一个列表元素之外，Python还提供了访问子列表的简明语法， 这被称为切片。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums=<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>)) <span class="comment">#创建int型list，从0开始的五个</span></span><br><span class="line"><span class="built_in">print</span>(nums) <span class="comment">#输出全部内容</span></span><br><span class="line"><span class="built_in">print</span>(nums[<span class="number">2</span>:<span class="number">4</span>]) <span class="comment">##输出第二个到第四个元素之前的内容</span></span><br><span class="line"><span class="built_in">print</span>(nums[<span class="number">2</span>:]) <span class="comment">#输出第二个到结尾的元素</span></span><br><span class="line"><span class="built_in">print</span>(nums[:<span class="number">2</span>]) <span class="comment">#输出第二个元素之前的内容</span></span><br><span class="line"><span class="built_in">print</span>(nums[:]) <span class="comment">#输出全部</span></span><br><span class="line"><span class="built_in">print</span>(nums[:-<span class="number">1</span>]) <span class="comment">#除了最后一个其他都输出</span></span><br><span class="line">nums[<span class="number">2</span>:<span class="number">4</span>]=[<span class="number">8</span>,<span class="number">9</span>] <span class="comment">#把第二个到第四个之前，即第2，3换成元素8，9</span></span><br><span class="line"><span class="built_in">print</span>(nums)</span><br></pre></td></tr></table></figure><p>(循环)Loops: 可以循环遍历列表的元素，如下所示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">animals=[<span class="string">&#x27;cat&#x27;</span>,<span class="string">&#x27;dog&#x27;</span>,<span class="string">&#x27;monkey&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> animals:</span><br><span class="line">    <span class="built_in">print</span>(animal)</span><br><span class="line"><span class="comment">#cat</span></span><br><span class="line"><span class="comment">#dog</span></span><br><span class="line"><span class="comment">#monkey</span></span><br></pre></td></tr></table></figure><p>如果要访问循环体内每个元素的索引，请使用内置的 enumerate 函数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">animals=[<span class="string">&#x27;cat&#x27;</span>,<span class="string">&#x27;dog&#x27;</span>,<span class="string">&#x27;monkey&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> idx,animal <span class="keyword">in</span> <span class="built_in">enumerate</span>(animals):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;#%d: %s&#x27;</span> % (idx+<span class="number">1</span>,animal))</span><br></pre></td></tr></table></figure><p>列表推导式(List comprehensions): 编程时，我们经常想要将一种数据转换为另一种数据。 举个简单的例子，思考以下计算平方数的代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">squares=[]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">    squares.append(x**<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(squares)</span><br><span class="line"></span><br><span class="line">nums2=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">squares=[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> nums2]</span><br><span class="line"><span class="built_in">print</span>(squares)</span><br><span class="line"></span><br><span class="line">nums3=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">even_squares=[x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> nums3 <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(even_squares)</span><br></pre></td></tr></table></figure><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>Python 的元组与列表类似</p><ul><li>不同之处在于元组的元素不能修改。</li><li>元组使用小括号，列表使用方括号。</li><li>元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。</li></ul><p>如下所示。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1=(<span class="string">&#x27;physics&#x27;</span>,<span class="string">&#x27;chemistry&#x27;</span>,<span class="number">1988</span>,<span class="number">2022</span>)</span><br><span class="line">tup2=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">tup3=<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span></span><br></pre></td></tr></table></figure><p>创建空元组</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1=()</span><br></pre></td></tr></table></figure><p>元组只包含一个元素时，需要在元素后面加逗号。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1=(<span class="number">50</span>,)</span><br></pre></td></tr></table></figure><p>元组与字符串类似，下标索引从0开始，可以进行截取，组合等。</p><h4 id="访问元组"><a href="#访问元组" class="headerlink" title="访问元组"></a>访问元组</h4><p>元组可以使用下标索引来访问元组中的值，如下实例。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1=(<span class="string">&#x27;physics&#x27;</span>,<span class="string">&#x27;chemistry&#x27;</span>,<span class="number">1988</span>,<span class="number">2022</span>)</span><br><span class="line">tup2=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(tup1[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(tup2(<span class="number">1</span>:<span class="number">4</span>))</span><br></pre></td></tr></table></figure><h4 id="修改元组"><a href="#修改元组" class="headerlink" title="修改元组"></a>修改元组</h4><p>元组中的元素值是不允许修改的，但我们可以对元组进行连接组合，如下实例。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1=(<span class="string">&#x27;physics&#x27;</span>,<span class="string">&#x27;chemistry&#x27;</span>,<span class="number">1988</span>,<span class="number">2022</span>)</span><br><span class="line">tup2=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tup1[0]=100 非法操作</span></span><br><span class="line">tup3=tup1+tup2</span><br><span class="line"><span class="built_in">print</span>(tup3)</span><br><span class="line"><span class="comment">#(&#x27;physics&#x27;, &#x27;chemistry&#x27;, 1988, 2022, 1, 2, 3, 4, 5)</span></span><br></pre></td></tr></table></figure><p>元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1=(<span class="string">&#x27;physics&#x27;</span>,<span class="string">&#x27;chemistry&#x27;</span>,<span class="number">1988</span>,<span class="number">2022</span>)</span><br><span class="line"><span class="keyword">del</span> tup1</span><br><span class="line"><span class="built_in">print</span>(tup1) <span class="comment">#删除后，输出变量会有异常信息</span></span><br></pre></td></tr></table></figure><h4 id="元组运算符"><a href="#元组运算符" class="headerlink" title="元组运算符"></a>元组运算符</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)))<span class="comment">#3计算元素个数</span></span><br><span class="line"><span class="built_in">print</span>((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) + (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>))<span class="comment">#(1, 2, 3, 4, 5, 6)连接</span></span><br><span class="line"><span class="built_in">print</span>((<span class="string">&#x27;Hi!&#x27;</span>,) * <span class="number">4</span>)<span class="comment">#(&#x27;Hi!&#x27;, &#x27;Hi!&#x27;, &#x27;Hi!&#x27;, &#x27;Hi!&#x27;)复制</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))<span class="comment">#True元素是否存在</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>): </span><br><span class="line">    <span class="built_in">print</span>(x)<span class="comment">#1 2 3迭代</span></span><br></pre></td></tr></table></figure><h4 id="元组索引"><a href="#元组索引" class="headerlink" title="元组索引"></a>元组索引</h4><p>因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素，如下所示。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup=(<span class="string">&#x27;sam&#x27;</span>,<span class="string">&#x27;lily&#x27;</span>,<span class="string">&#x27;lucy&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(tup[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(tup[-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(tup[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure><h4 id="无关闭分隔符"><a href="#无关闭分隔符" class="headerlink" title="无关闭分隔符"></a>无关闭分隔符</h4><p>任意无符号的对象，以逗号隔开，默认为元组。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;abc&#x27;</span>, -<span class="number">4.24e93</span>, <span class="number">18</span>+<span class="number">6.6j</span>, <span class="string">&#x27;xyz&#x27;</span>)</span><br><span class="line">x, y = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Value of x , y : &quot;</span>, x,y)</span><br><span class="line"><span class="comment">#abc -4.24e+93 (18+6.6j) xyz</span></span><br><span class="line"><span class="comment">#Value of x , y :  1 2</span></span><br></pre></td></tr></table></figure><h4 id="元组内置函数"><a href="#元组内置函数" class="headerlink" title="元组内置函数"></a>元组内置函数</h4><ol><li>cmp(tuple1, tuple2)【比较两个元组元素】</li><li>len(tuple)【计算元组元素个数】</li><li>max(tuple)【返回元组中元素最大值】</li><li>min(tuple)【返回元组中元素最小值】</li><li>tuple(seq)【将列表转换为元组】</li></ol><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典是另一种可变容器模型，且可存储任意类型对象。<br>字典的每个键值 key:value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中 ,格式如下所示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;key1 : value1, key2 : value2 &#125;</span><br></pre></td></tr></table></figure><ul><li>键一般是唯一的，如果重复最后的一个键值对会替换前面的，值不需要唯一。</li><li>值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。<br>一个简单的字典实例：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1=&#123;<span class="string">&#x27;Alice&#x27;</span>:<span class="string">&#x27;1234&#x27;</span>,<span class="string">&#x27;Beth&#x27;</span>:<span class="string">&#x27;4567&#x27;</span>,<span class="string">&#x27;Cecil&#x27;</span>:<span class="string">&#x27;9876&#x27;</span>&#125;</span><br><span class="line">dict2=&#123;<span class="string">&#x27;abc&#x27;</span>:<span class="number">456</span>&#125;</span><br><span class="line">dict3=&#123;<span class="string">&#x27;abc&#x27;</span>:<span class="number">123</span>,<span class="number">98.6</span>:<span class="number">37</span>&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="访问字典里的值"><a href="#访问字典里的值" class="headerlink" title="访问字典里的值"></a>访问字典里的值</h4><p>把相应的键放入熟悉的方括弧。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1=&#123;<span class="string">&#x27;Alice&#x27;</span>:<span class="string">&#x27;1234&#x27;</span>,<span class="string">&#x27;Beth&#x27;</span>:<span class="string">&#x27;4567&#x27;</span>,<span class="string">&#x27;Cecil&#x27;</span>:<span class="string">&#x27;9876&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(dict1[<span class="string">&#x27;Alice&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(dict1[<span class="string">&#x27;Cecil&#x27;</span>])</span><br></pre></td></tr></table></figure><p>如果用字典里没有的键访问数据，会输出错误如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1=&#123;<span class="string">&#x27;Alice&#x27;</span>:<span class="string">&#x27;1234&#x27;</span>,<span class="string">&#x27;Beth&#x27;</span>:<span class="string">&#x27;4567&#x27;</span>,<span class="string">&#x27;Cecil&#x27;</span>:<span class="string">&#x27;9876&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(dict1[<span class="string">&#x27;Lisa&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#  File &quot;D:/study/pythonstudy/test1.py&quot;, line 2, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#    print(dict1[&#x27;Lisa&#x27;])</span></span><br><span class="line"><span class="comment"># KeyError: &#x27;Lisa&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="修改字典"><a href="#修改字典" class="headerlink" title="修改字典"></a>修改字典</h4><p>向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对如下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1=&#123;<span class="string">&#x27;Alice&#x27;</span>:<span class="string">&#x27;1234&#x27;</span>,<span class="string">&#x27;Beth&#x27;</span>:<span class="string">&#x27;4567&#x27;</span>,<span class="string">&#x27;Cecil&#x27;</span>:<span class="string">&#x27;9876&#x27;</span>&#125;</span><br><span class="line">dict1[<span class="string">&#x27;Alice&#x27;</span>]=<span class="number">999</span></span><br><span class="line">dict1[<span class="string">&#x27;Beth&#x27;</span>]=<span class="number">888</span></span><br><span class="line"><span class="built_in">print</span>(dict1[<span class="string">&#x27;Alice&#x27;</span>]) <span class="comment">#999</span></span><br><span class="line"><span class="built_in">print</span>(dict1[<span class="string">&#x27;Beth&#x27;</span>]) <span class="comment">#888</span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>以下是简单的规则：</p><ul><li>函数代码块以 def 关键词开头，后接函数标识符名称和圆括号()。</li><li>任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。</li><li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</li><li>函数内容以冒号起始，并且缩进。</li><li>return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</li></ul><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> x&gt;<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;positive&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> x&lt;<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;negative&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;zero&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span>[-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]:</span><br><span class="line">    <span class="built_in">print</span>(sign(x))</span><br></pre></td></tr></table></figure><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>定义一个函数只给了函数一个名称，指定了函数里包含的参数，和代码块结构。<br>这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从Python提示符执行。<br>如下实例调用了printme（）函数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printme</span>(<span class="params"><span class="built_in">str</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">printme(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>在 python 中，类型属于对象，变量是没有类型的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a=<span class="string">&quot;helloworld&quot;</span></span><br></pre></td></tr></table></figure><p>以上代码中，[1,2,3]是List类型，”helloworld”是String类型，而变量a没有类型，仅仅是一个对象的引用（一个指针），可以是List类型对象，也可以是String类型对象。</p><h4 id="可更改与不可更改对象"><a href="#可更改与不可更改对象" class="headerlink" title="可更改与不可更改对象"></a>可更改与不可更改对象</h4><p>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p><ul><li>不可变类型：变量赋值a=5后再赋值a=10，这里实际是新生成一个int值对象10，再让a指向它，而5被丢弃，不是改变a的值，相当于新生成了a。</li><li>可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</li></ul><p>python 函数的参数传递：</p><ul><li><p>不可变类型：类似 c++ 的值传递，如整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改a的值，只是修改另一个复制的对象，不会影响a本身。</p></li><li><p>可变类型：类似 c++ 的引用传递，如列表，字典。如 fun（la），则是将la真正的传过去，修改后fun外部的la也会受影响。</p></li></ul><p>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</p><h4 id="传不可变对象实例"><a href="#传不可变对象实例" class="headerlink" title="传不可变对象实例"></a>传不可变对象实例</h4><p>示例如下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params"> a </span>):</span><br><span class="line">    a=<span class="number">10</span></span><br><span class="line"></span><br><span class="line">b=<span class="number">2</span></span><br><span class="line">change(b)</span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment">#b=2</span></span><br></pre></td></tr></table></figure><p>实例中有int对象2，指向它的变量是b，在传递给change函数时，按传值的方式复制了变量b，a和b都指向了同一个int对象，在a=10时，则新生成一个int值对象 10，并让a指向它。</p><h4 id="传可变对象实例"><a href="#传可变对象实例" class="headerlink" title="传可变对象实例"></a>传可变对象实例</h4><p>示例如下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params"> <span class="built_in">list</span> </span>):</span><br><span class="line">    <span class="built_in">list</span>.append([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in function list:&quot;</span>,<span class="built_in">list</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>=[<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>]</span><br><span class="line">change(<span class="built_in">list</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;out function list:&quot;</span>,<span class="built_in">list</span>)</span><br><span class="line"><span class="comment">#in function list: [10, 9, 8, [1, 2, 3, 4]]</span></span><br><span class="line"><span class="comment">#out function list: [10, 9, 8, [1, 2, 3, 4]]</span></span><br></pre></td></tr></table></figure><p>实例中传入函数的和在末尾添加新内容的对象用的是同一个引用。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>以下是调用函数时可使用的正式参数类型：</p><ul><li><p><strong>必备参数</strong><br>必备参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。</p></li><li><p><strong>关键字参数</strong><br>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为Python解释器能够用参数名匹配参数值。<br>下面的例子说明关键字参数顺序不重要。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> name , age </span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Name:&quot;</span>,name)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Age:&quot;</span>,age)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">  printinfo(age=<span class="number">18</span>,name=<span class="string">&quot;lihua&quot;</span>)</span><br><span class="line">  <span class="comment">#Name: lihua</span></span><br><span class="line">  <span class="comment">#Age: 18</span></span><br></pre></td></tr></table></figure></li><li><p><strong>默认参数</strong><br>  调用函数时，默认参数的值如果没有传入，则被认为是默认值。下例会打印默认的age，如果age没有被传入。</p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> name , age = <span class="number">35</span> </span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Name:&quot;</span>,name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Age:&quot;</span>,age)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">printinfo(age=<span class="number">23</span>,name=<span class="string">&quot;xiaoming&quot;</span>)</span><br><span class="line">printinfo(name=<span class="string">&quot;angela&quot;</span>)</span><br><span class="line"><span class="comment">#Name: xiaoming</span></span><br><span class="line"><span class="comment">#Age: 23</span></span><br><span class="line"><span class="comment">#Name: angela</span></span><br><span class="line"><span class="comment">#Age: 35</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>不定长参数</strong><br>  你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下(加了星号（*）的变量名会存放所有未命名的变量参数)  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> arg1 , *vartuple</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;输出：&quot;</span>)</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;arg:&quot;</span>,arg1)</span><br><span class="line">  <span class="keyword">for</span> var <span class="keyword">in</span> vartuple:</span><br><span class="line">     <span class="built_in">print</span>(var)</span><br><span class="line"> <span class="keyword">return</span></span><br><span class="line">printinfo(<span class="number">10</span>)</span><br><span class="line">printinfo(<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>)</span><br><span class="line"><span class="comment">#输出：</span></span><br><span class="line"><span class="comment">#arg: 10</span></span><br><span class="line"><span class="comment">#输出：</span></span><br><span class="line"><span class="comment">#arg: 70</span></span><br><span class="line"><span class="comment">#60</span></span><br><span class="line"><span class="comment">#50</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>python使用lambda来创建匿名函数。</p><ul><li>lambda只是一个表达式，函数体比def简单很多。</li><li>lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。</li><li>lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。</li><li>虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</li></ul><p>lambda函数语法只包含一个语句，如下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> [arg1 [,arg2,.....argn]]:expression</span><br></pre></td></tr></table></figure><p>具体如下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sum</span> = <span class="keyword">lambda</span> arg1,arg2:arg1+arg2</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sum:&quot;</span>,<span class="built_in">sum</span>(<span class="number">10</span>,<span class="number">20</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sum:&quot;</span>,<span class="built_in">sum</span>(<span class="number">10</span>,<span class="number">50</span>))</span><br><span class="line"><span class="comment">#sum: 30</span></span><br><span class="line"><span class="comment">#sum: 60</span></span><br></pre></td></tr></table></figure><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>一个程序的所有的变量并不是在哪个位置都可以访问的。访问权限决定于这个变量是在哪里赋值的。<br>变量的作用域决定了在哪一部分程序你可以访问哪个特定的变量名称。两种最基本的变量作用域如下：</p><ul><li>全局变量</li><li>局部变量<h4 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h4>定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。</li></ul><p>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total = <span class="number">0</span> <span class="comment">#全局变量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params"> arg1, arg2</span>):</span><br><span class="line">    total=arg1+arg2</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数内是局部变量：&quot;</span>,total)</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"><span class="built_in">sum</span>(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;函数外是全局变量：&quot;</span>,total)</span><br><span class="line"><span class="comment">#函数内是局部变量： 30</span></span><br><span class="line"><span class="comment">#函数外是全局变量： 0</span></span><br></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象简介"><a href="#面向对象简介" class="headerlink" title="面向对象简介"></a>面向对象简介</h3><ol><li><p>类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</p></li><li><p>类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</p></li><li><p>数据成员：类变量或者实例变量, 用于处理类及其实例对象的相关的数据。</p></li><li><p>方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</p></li><li><p>局部变量：定义在方法中的变量，只作用于当前实例的类。</p></li><li><p>实例变量：在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。</p></li><li><p>继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。</p></li><li><p>实例化：创建一个类的实例，类的具体对象。</p></li><li><p>方法：类中定义的函数。</p></li><li><p>对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</p></li></ol><h3 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h3><p>使用 class 语句来创建一个新类，class 之后为类的名称并以冒号结尾:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>:</span><br><span class="line">   <span class="string">&#x27;类的帮助信息&#x27;</span>   <span class="comment">#类文档字符串</span></span><br><span class="line">   class_suite  <span class="comment">#类体</span></span><br></pre></td></tr></table></figure><p>class_suite 由类成员，方法，数据属性组成。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>:</span><br><span class="line">    empcnt=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,salary</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.salary=salary</span><br><span class="line">        Employee.empcnt+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">displayCount</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;total employee %d&quot;</span> % Employee.empcnt)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">displayEmployee</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;name&quot;</span>,self.name,<span class="string">&quot;,salary&quot;</span>,self.salary)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>empcnt</code> 变量是一个类变量，它的值将在这个类的所有实例之间共享。你可以在内部类或外部类使用 Employee.empCount 访问。</p><p>第一种方法<code>__init__()</code>方法是一种特殊的方法，被称为类的<strong>构造函数或初始化方法</strong>，当创建了这个类的实例时就会调用该方法</p><p><code>self</code> 代表类的实例，<code>self</code> 在定义类的方法时是必须有的，虽然在调用时不必传入相应的参数。</p><h4 id="self代表类的实例，而非类"><a href="#self代表类的实例，而非类" class="headerlink" title="self代表类的实例，而非类"></a>self代表类的实例，而非类</h4><p>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prt</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line">        <span class="built_in">print</span>(self.__class__)</span><br><span class="line">        </span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;__main__.Test <span class="built_in">object</span> at <span class="number">0x000002A13A90A5C0</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Test&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>从执行结果可以很明显的看出，<code>self </code>代表的是<strong>类的实例</strong>，代表<strong>当前对象的地址</strong>，而 self.<strong>class</strong> 则指向类。</p><p><code>self</code> 不是 python 关键字，我们把他换成 jupiter 也是可以正常执行的。输出结果与self一致。</p><h4 id="python内置属性"><a href="#python内置属性" class="headerlink" title="python内置属性"></a>python内置属性</h4><p><code>__dict__ </code>: 类的属性（包含一个字典，由类的数据属性组成）<br><code>__doc__ </code>: 类的文档字符串<br><code>__name__</code>: 类名<br><code>__module__</code>: 类定义所在的模块（类的全名是<code>&#39;__main__.className&#39;</code>，如果类位于一个导入模块mymod中，那么<code>className.__module__</code> 等于 mymod）<br><code>__bases__</code> : 类的所有父类构成元素（包含了一个由所有父类组成的元组）</p><h2 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h2><p>一些基础用法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])   <span class="comment"># Create a rank 1 array</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))            <span class="comment"># Prints &quot;&lt;class &#x27;numpy.ndarray&#x27;&gt;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a.shape)            <span class="comment"># Prints &quot;(3,)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>])   <span class="comment"># Prints &quot;1 2 3&quot;</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">5</span>                  <span class="comment"># Change an element of the array</span></span><br><span class="line"><span class="built_in">print</span>(a)                  <span class="comment"># Prints &quot;[5, 2, 3]&quot;</span></span><br><span class="line"></span><br><span class="line">b = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])    <span class="comment"># Create a rank 2 array</span></span><br><span class="line"><span class="built_in">print</span>(b.shape)                     <span class="comment"># Prints &quot;(2, 3)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(b[<span class="number">0</span>, <span class="number">0</span>], b[<span class="number">0</span>, <span class="number">1</span>], b[<span class="number">1</span>, <span class="number">0</span>])   <span class="comment"># Prints &quot;1 2 4&quot;</span></span><br></pre></td></tr></table></figure><p>Numpy还提供了很多创建数组的函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.zeros((<span class="number">2</span>,<span class="number">2</span>))   <span class="comment"># Create an array of all zeros</span></span><br><span class="line"><span class="built_in">print</span>(a)              <span class="comment"># Prints &quot;[[ 0.  0.]</span></span><br><span class="line">                      <span class="comment">#          [ 0.  0.]]&quot;</span></span><br><span class="line"></span><br><span class="line">b = np.ones((<span class="number">1</span>,<span class="number">2</span>))    <span class="comment"># Create an array of all ones</span></span><br><span class="line"><span class="built_in">print</span>(b)              <span class="comment"># Prints &quot;[[ 1.  1.]]&quot;</span></span><br><span class="line"></span><br><span class="line">c = np.full((<span class="number">2</span>,<span class="number">2</span>), <span class="number">7</span>)  <span class="comment"># Create a constant array</span></span><br><span class="line"><span class="built_in">print</span>(c)               <span class="comment"># Prints &quot;[[ 7.  7.]</span></span><br><span class="line">                       <span class="comment">#          [ 7.  7.]]&quot;</span></span><br><span class="line"></span><br><span class="line">d = np.eye(<span class="number">2</span>)         <span class="comment"># Create a 2x2 identity matrix</span></span><br><span class="line"><span class="built_in">print</span>(d)              <span class="comment"># Prints &quot;[[ 1.  0.]</span></span><br><span class="line">                      <span class="comment">#          [ 0.  1.]]&quot;</span></span><br><span class="line"></span><br><span class="line">e = np.random.random((<span class="number">2</span>,<span class="number">2</span>))  <span class="comment"># Create an array filled with random values</span></span><br><span class="line"><span class="built_in">print</span>(e)                     <span class="comment"># Might print &quot;[[ 0.91940167  0.08143941]</span></span><br><span class="line">                             <span class="comment">#               [ 0.68744134  0.87236687]]&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>刷题记录(坚持就是胜利）</title>
      <link href="/2022/09/30/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%9D%9A%E6%8C%81%E5%B0%B1%E6%98%AF%E8%83%9C%E5%88%A9%EF%BC%89/"/>
      <url>/2022/09/30/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%9D%9A%E6%8C%81%E5%B0%B1%E6%98%AF%E8%83%9C%E5%88%A9%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="算法设计与分析"><a href="#算法设计与分析" class="headerlink" title="算法设计与分析"></a>算法设计与分析</h1><h2 id="2-1-众数问题"><a href="#2-1-众数问题" class="headerlink" title="2-1 众数问题"></a>2-1 众数问题</h2><h3 id="（一）题目"><a href="#（一）题目" class="headerlink" title="（一）题目"></a>（一）题目</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定含有n个元素的多重集合S，每个元素在S中出现的次数称为该元素的重数。多重集S中重数最大的元素称为众数。例如：S={1,2,2,3,5}。多重集S的众数是2，其重数为3。</p><h4 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h4><p>对于给定的由n个自然数组成的多重集S，计算S的众数及其重数。</p><h4 id="数据输入"><a href="#数据输入" class="headerlink" title="数据输入"></a>数据输入</h4><p>输入数据由文件名为input.txt的文本文件提供。文件的第一行为多重集 中元素个数n，接下来的n行中，每行有一个自然数。</p><h4 id="结果输出"><a href="#结果输出" class="headerlink" title="结果输出"></a>结果输出</h4><p>将计算结果输出到文件output.txt。输出文件有两行，第1行是众数，第2行是重数。</p><h3 id="（二）解法"><a href="#（二）解法" class="headerlink" title="（二）解法"></a>（二）解法</h3><p>首先对数组进行排序，之后找到数组的mid，并通过循环找到mid的左边界和右边界并记录mid的重数。此时，整段数组被分为三段。[0,mid左边界][mid][mid右边界,n]。再判断三段的大小，如果左右两段的长度小于mid的重数，则不可能有数字重数比mid更大；否则，则更新边界，在段内搜索是否有更大的重数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModeTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读入txt文件函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] file2StringArray(File file) &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(file));</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span>( (str = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">int</span> number=Integer.parseInt(str);</span><br><span class="line">                list.add(number);</span><br><span class="line">            &#125;</span><br><span class="line">            br.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> ( IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] num=<span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        Integer[] int_arr=<span class="keyword">new</span> <span class="title class_">Integer</span>[list.size()];</span><br><span class="line">        int_arr=list.toArray(int_arr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;int_arr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            num[i]=int_arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//快速排序函数</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span>[] num,<span class="type">int</span> p,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> q=Partition(num,p,r);</span><br><span class="line">            QuickSort(num,p,q-<span class="number">1</span>);</span><br><span class="line">            QuickSort(num,q+<span class="number">1</span>,r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组分段</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">Partition</span><span class="params">(<span class="type">int</span>[] num,<span class="type">int</span> p,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i=p,j=r+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> x=num[p];</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(num[--j]&gt;x&amp;&amp;j&gt;<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span>(num[++i]&lt;=x);</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=j)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(num,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        num[p]=num[j];</span><br><span class="line">        num[j]=x;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] num,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> temp=num[i];</span><br><span class="line">        num[i]=num[j];</span><br><span class="line">        num[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找众数和其重数函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] findMaxCnt(<span class="type">int</span>[] num,<span class="type">int</span> l,<span class="type">int</span> r)&#123;</span><br><span class="line">        <span class="type">int</span>[] help=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];<span class="comment">//辅助数组，记录众数和众数重数</span></span><br><span class="line">        <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> pos_max;<span class="comment">//众数</span></span><br><span class="line">        <span class="type">int</span> cnt_max=<span class="number">0</span>;<span class="comment">//最大重数</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> pos_temp=<span class="number">0</span>;<span class="comment">//子序列划分点</span></span><br><span class="line">        <span class="type">int</span> cnt_temp=<span class="number">0</span>;<span class="comment">//子序列重数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以中位数为界限，划分为两段。</span></span><br><span class="line">        <span class="comment">//寻找左段右边界和右段左边界</span></span><br><span class="line">        <span class="type">int</span> midnum=num[mid];</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=l;i&lt;=r;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i]==midnum)&#123;</span><br><span class="line">                left=i-<span class="number">1</span>;<span class="comment">//找到左段的右边界</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;=r;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i]!=midnum)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right=i;<span class="comment">//找到右段的左边界</span></span><br><span class="line"></span><br><span class="line">        cnt_max=right-left-<span class="number">1</span>;<span class="comment">//众数的重数</span></span><br><span class="line">        pos_max=midnum;<span class="comment">//众数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//分治，判断左右两段的长度是否大于当前众数的重数</span></span><br><span class="line">        <span class="comment">//如果大于，说明有可能会更改众数</span></span><br><span class="line">        <span class="keyword">if</span>((left-l+<span class="number">1</span>)&gt;cnt_max)&#123;</span><br><span class="line">            cnt_temp=findMaxCnt(num,l,left)[<span class="number">1</span>];</span><br><span class="line">            pos_temp=findMaxCnt(num,l,left)[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(cnt_temp&gt;cnt_max)&#123;</span><br><span class="line">                pos_max=pos_temp;</span><br><span class="line">                cnt_max=cnt_temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((r-right+<span class="number">1</span>)&gt;cnt_max)&#123;</span><br><span class="line">            cnt_temp=findMaxCnt(num,right,r)[<span class="number">1</span>];</span><br><span class="line">            pos_max=findMaxCnt(num,right,r)[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(cnt_temp&gt;cnt_max)&#123;</span><br><span class="line">                pos_max=pos_temp;</span><br><span class="line">                cnt_max=cnt_temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新辅助数组的值</span></span><br><span class="line">        help[<span class="number">0</span>]=pos_max;</span><br><span class="line">        help[<span class="number">1</span>]=cnt_max;</span><br><span class="line">        <span class="keyword">return</span> help;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="comment">//读入文件，获取数组</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/study/大三上/算法/2_1_in.txt&quot;</span>);</span><br><span class="line">        <span class="type">int</span>[] A=file2StringArray(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先对数组进行排序，然后调用众数相关函数</span></span><br><span class="line">        ModeTest tt=<span class="keyword">new</span> <span class="title class_">ModeTest</span>();</span><br><span class="line">        tt.QuickSort(A,<span class="number">0</span>,A.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将结果输出到txt文件</span></span><br><span class="line">        PrintStream ps=<span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;D:/study/大三上/算法/2_1_out.txt&quot;</span>);</span><br><span class="line">        System.setOut(ps);</span><br><span class="line">        System.out.println(A[findMaxCnt(A,<span class="number">0</span>,A.length-<span class="number">1</span>)[<span class="number">0</span>]]);<span class="comment">//输出众数</span></span><br><span class="line">        System.out.println(+findMaxCnt(A,<span class="number">0</span>,A.length-<span class="number">1</span>)[<span class="number">1</span>]);<span class="comment">//输出重数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-3-半数集问题"><a href="#2-3-半数集问题" class="headerlink" title="2-3 半数集问题"></a>2-3 半数集问题</h2><p>题目：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HalfSet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">file2StringArray</span><span class="params">(File file)</span> &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(file));</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span>( (str = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                num=Integer.parseInt(str);</span><br><span class="line">            &#125;</span><br><span class="line">            br.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> ( IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用数组num来记录已经计算过的半数集，以此来避免重复计算</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">CountHalfSet</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span>[] num)</span>&#123;</span><br><span class="line">        <span class="comment">//已经记录过则直接调用</span></span><br><span class="line">        <span class="keyword">if</span>(num[n]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> num[n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没记录的，进行递归</span></span><br><span class="line">        <span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            sum+=CountHalfSet(i,num);</span><br><span class="line">        &#125;</span><br><span class="line">        num[n]=sum;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/study/大三上/算法/2_3_in.txt&quot;</span>);</span><br><span class="line">        <span class="type">int</span> number=file2StringArray(file);</span><br><span class="line">        HalfSet tt=<span class="keyword">new</span> <span class="title class_">HalfSet</span>();</span><br><span class="line">        <span class="type">int</span>[] num=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1000</span>];</span><br><span class="line">        PrintStream ps=<span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;D:/study/大三上/算法/2_3_out.txt&quot;</span>);</span><br><span class="line">        System.setOut(ps);</span><br><span class="line">        System.out.println(tt.CountHalfSet(number,num));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="leetcode动态规划"><a href="#leetcode动态规划" class="headerlink" title="leetcode动态规划"></a>leetcode动态规划</h2><h3 id="2022-10-03"><a href="#2022-10-03" class="headerlink" title="2022-10-03"></a>2022-10-03</h3><p>斐波那契数 （通常用 F(n) 表示）形成的序列称为斐波那契数列该数列由0和1开始，后面的每一项数字都是前面两项数字的和。也就是：<br>F(0)=0，F(1)= 1<br>F(n)=F(n-1)+F(n-2)，其中n&gt;1<br>给定n，请计算F(n)。</p><p>由于存在递推关系，可以使用动态规划求解。状态转移方程即为上述的递推关系，边界条件是F(0)&amp;F(1)。使用滚动数组思想。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> prev=<span class="number">1</span>,curr=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> sum=prev+curr;</span><br><span class="line">            prev=curr;</span><br><span class="line">            curr=sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2022-10-08"><a href="#2022-10-08" class="headerlink" title="2022-10-08"></a>2022-10-08</h3><p>泰波那契序列 Tn 定义如下： <br>T0 = 0, T1 = 1, T2 = 1, 且在 n &gt;= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2<br>给你整数 n，请返回第 n 个泰波那契数 Tn 的值。</p><p>泰波那契数的边界条件是 T(0)=0, T(1)=1, T(2)=1。当 n&gt;2 时，每一项的和都等于前三项的和，因此有如下递推关系：T(n)=T(n-1)+T(n-2)+T(n-3)。由于泰波那契数存在递推关系，因此可以使用动态规划求解。动态规划的状态转移方程即为上述递推关系，边界条件为T(0)、T(1)和T(2)。<br>使用所谓的”滚动数组思想”。为了填补i=3时循环的空缺，需要增加一个等于0的值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">tribonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num_n=<span class="number">0</span>,num_n1=<span class="number">0</span>,num_n2=<span class="number">1</span>,num_n3=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;           </span><br><span class="line">            num_n=num_n1;</span><br><span class="line">            num_n1=num_n2;</span><br><span class="line">            num_n2=num_n3;</span><br><span class="line">            num_n3=num_n+num_n1+num_n2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num_n3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2022-10-09"><a href="#2022-10-09" class="headerlink" title="2022-10-09"></a>2022-10-09</h3><p>假设你正在爬楼梯。需要n阶你才能到达楼顶。<br>每次你可以爬1或2个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>示例 1：<br>输入：n = 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶</li><li>2 阶<br>示例 2：</li></ol><p>输入：n = 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ol><p> <br>提示：<br>1 &lt;= n &lt;= 45</p><p>滚动数组思想<br>动态转移方程：f(x)=f(x−1)+f(x−2)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> step1=<span class="number">0</span>,step2=<span class="number">0</span>,step3=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            step1=step2;</span><br><span class="line">            step2=step3;</span><br><span class="line">            step3=step1+step2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2022-10-10"><a href="#2022-10-10" class="headerlink" title="2022-10-10"></a>2022-10-10</h3><p>设费用数组cost的长度为n，n个楼梯分别对应下标0~n-1。楼层顶部对应n。问题转化为计算从起点0或1到达n的最小代价。该问题具有最优子结构。<br>创建数组dp，长度为n+1，dp[i]代表达到下标i的最小代价。考虑到可以选择下标0或1作为起始，因此初始化dp[0]=dp[1]=0。</p><p><strong>对于2&lt;=i&lt;=n时，有两种爬楼梯方法。</strong></p><ol><li>从下标i-1，花费cost[i-1]到达下标i。</li><li>从下标i-2，花费cost[i-2]到达下标i。</li></ol><p>为求解最终答案，对每一个下标来说，dp[i]应该为这两者的最小值，由此可得如下状态方程。<br>dp[i]=min{dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]}<br>迭代计算dp中的每一项，最终得到dp[n]的值即为到达最顶层的最小代价。</p><p>具体代码如下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=cost.length;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>]; <span class="comment">//存放到达下标i的最小代价</span></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>; <span class="comment">//可以从0或者1出发，所以这两个值初始化为0</span></span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=Math.min(dp[i-<span class="number">1</span>]+cost[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+cost[i-<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n]; <span class="comment">//到达楼顶n的最小代价</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2022-10-11-打家劫舍"><a href="#2022-10-11-打家劫舍" class="headerlink" title="2022-10-11 打家劫舍"></a>2022-10-11 打家劫舍</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p>示例 1：<br>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 。</p><p>示例 2：<br>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p><p>提示：<br>1 &lt;= nums.length &lt;= 100<br>0 &lt;= nums[i] &lt;= 400</p><p>分步骤考虑。</p><ol><li>如果只有一间房子，选择偷窃。如果有两间房子，选择两个里面金额更高的偷窃。</li><li>第k个房子(k&gt;2)，在以下2种策略中选择金额较大的选项：<ul><li>偷窃第k间房子，不能偷k-1间房子，此时金额为偷窃<strong>前k-2间房屋累积的金额+偷窃第k间房子</strong>的金额。</li><li>不偷第k间房子，金额为<strong>前k-1间房子</strong>累积的金额。</li></ul></li></ol><p>创建dp[i]表示到达第k间房子时获得的金额，得到以下状态转移方程。<br>dp[i]=max{dp[i-2]+nums[i],dp[i-1]}<br>边界条件如下：<br>dp[0]=nums[0]<br>dp[1]=max{nums[0],nums[1]}<br>得到dp[n-1]即为所求答案。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;<span class="comment">//一共只有一间房子</span></span><br><span class="line">                <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//多个房子的情况</span></span><br><span class="line">            <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">            dp[<span class="number">0</span>]=nums[<span class="number">0</span>]; <span class="comment">//一间房子时只有一种策略</span></span><br><span class="line">            dp[<span class="number">1</span>]=Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]); <span class="comment">//两间房子时可以选择1号or2号房</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">                dp[i]=Math.max(dp[i-<span class="number">2</span>]+nums[i],dp[i-<span class="number">1</span>]); <span class="comment">//状态转移方程 任意房间i 有两种策略</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2022-10-12-打家劫舍Ⅱ"><a href="#2022-10-12-打家劫舍Ⅱ" class="headerlink" title="2022-10-12 打家劫舍Ⅱ"></a>2022-10-12 打家劫舍Ⅱ</h3><p>分情况考虑。</p><ol><li>假设只有一间房子，则偷窃这个房子，金额就是能够获得的最大的金额。</li><li>假设有两间房子，只能偷窃其中之一，选其中金额更大的进行偷窃。</li></ol><p>以上两种情况只能偷窃一间房子，不用考虑首尾相连情况。</p><ol start="3"><li>超过两间房子时，分为两种情况。<br>a. 偷了第一间，不能偷最后一间只能偷到倒数第二间。范围为第一间到倒数第二间。<br>b. 偷了最后一间，不能偷第一间只能从第二间开始偷。范围为第二间到最后一间。</li></ol><p>设数组nums长度为n，则3a的偷窃范围为[0,n-2]，3b的偷窃范围为[1,n-1]。考虑对打家劫舍简单版的代码进行改进，设置出下标的范围（起始与结束，之后就能套用）最终的总金额即为在这两种里面挑选最大的一种。</p><p>创建dp[i]表示到达第k间房子时获得的金额，得到以下状态转移方程。<br>dp[i]=max{dp[i-2]+nums[i],dp[i-1]}</p><p>边界条件：<br>dp[start]=nums[start]<br>dp[start+1]=max{nums[start],nums[start+1]}</p><p>取[0,n-2]，[1,n-1]为[start,end]，计算出两个里面最大的，得到dp[end]即为所求答案。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123; <span class="comment">//只有一间房子</span></span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.length==<span class="number">2</span>)&#123; <span class="comment">//两间房子选金额最大的</span></span><br><span class="line">            <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=Math.max(robhelp(<span class="number">0</span>,nums.length-<span class="number">2</span>,nums),robhelp(<span class="number">1</span>,nums.length-<span class="number">1</span>,nums));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">robhelp</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> one=nums[start]; <span class="comment">//起始的第一间房</span></span><br><span class="line">        <span class="type">int</span> two=Math.max(nums[start],nums[start+<span class="number">1</span>]); <span class="comment">//起始的第二间房</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start+<span class="number">2</span>;i&lt;=end;i++)&#123; <span class="comment">//从起始的第三间房开始，迭代到最后一间房</span></span><br><span class="line">            <span class="type">int</span> temp=two;</span><br><span class="line">            two=Math.max(one+nums[i],two);</span><br><span class="line">            one=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> two;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p><h3 id="2022-10-13-删除并获得点数"><a href="#2022-10-13-删除并获得点数" class="headerlink" title="2022-10-13 删除并获得点数"></a>2022-10-13 删除并获得点数</h3><p>给你一个整数数组 nums ，你可以对它进行一些操作。<br>每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。<br>开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。</p><p>示例 1：<br>输入：nums = [3,4,2]<br>输出：6<br>解释：<br>删除 4 获得 4 个点数，因此 3 也被删除。<br>之后，删除 2 获得 2 个点数。总共获得 6 个点数。<br>示例 2：<br>输入：nums = [2,2,3,3,3,4]<br>输出：9<br>解释：<br>删除 3 获得 3 个点数，接着要删除两个 2 和 4 。<br>之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。<br>总共获得 9 个点数。</p><p>提示：<br>1 &lt;= nums.length &lt;= 2 * 104<br>1 &lt;= nums[i] &lt;= 104</p><p><strong>解题思路</strong><br>可以划归为打家劫舍问题。<br>首先在nums数组中找出最大的一个数，然后以这个最大数为容量创建一个数组sum，用来保存nums中同一数字相加时获得的总和（删掉这个数字可以获得的全部点数）。之后，遍历nums数组，根据nums中元素的值定位到sum数组相应的位置，并更新sum数组中的数为当前该数字的累加和。最后把sum数组传入rob函数，跟打家劫舍的思路一致，最后可以得到答案。</p><p>无法同时偷窃相邻的房子 = 删除i-1和i+1的元素<br>可以抢劫的金额 = 删除某个元素获得的点数</p><p><strong>具体代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    public <span class="built_in">int</span> deleteAndEarn(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">max</span>=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="built_in">max</span>)</span><br><span class="line">                <span class="built_in">max</span>=nums[i]; //找到最大数</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span>[] <span class="built_in">sum</span>=new <span class="built_in">int</span>[<span class="built_in">max</span>+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="built_in">sum</span>[nums[j]]+=nums[j]; //统计每个数字的和</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rob(<span class="built_in">sum</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="built_in">int</span> rob(<span class="built_in">int</span>[] nums)&#123;</span><br><span class="line">        <span class="built_in">int</span> prev=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">int</span> curr=Math.<span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">2</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="built_in">int</span> temp=curr;</span><br><span class="line">            curr=Math.<span class="built_in">max</span>(prev+nums[i],curr);</span><br><span class="line">            prev=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(N+M),N为nums数组长度，M为sum数组长度<br>空间复杂度：O(M)</p><h3 id="2022-10-15-跳跃问题"><a href="#2022-10-15-跳跃问题" class="headerlink" title="2022-10-15 跳跃问题"></a>2022-10-15 跳跃问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;=max)&#123;<span class="comment">//说明位置i可达</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i]+i&gt;=max)&#123; <span class="comment">//从位置i跳跃的最大距离大于当前最远距离的话更新最远距离</span></span><br><span class="line">                    max=nums[i]+i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max&gt;=nums.length-<span class="number">1</span>)&#123;<span class="comment">//如果最大长度大于数组长度，则证明可以到达</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2022-10-16-跳跃问题Ⅱ"><a href="#2022-10-16-跳跃问题Ⅱ" class="headerlink" title="2022-10-16 跳跃问题Ⅱ"></a>2022-10-16 跳跃问题Ⅱ</h3><p>给你一个非负整数数组 nums ，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。假设你总是可以到达数组的最后一个位置。</p><p>示例 1:<br>输入: nums = [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。<br>示例 2:<br>输入: nums = [2,3,0,1,4]<br>输出: 2</p><p>提示:</p><p>1 &lt;= nums.length &lt;= 104<br>0 &lt;= nums[i] &lt;= 1000</p><p>解题思路：<br>从后向前找可以抵达这个点的下标。首先从最后一个位置开始，找到能够到达该点的下标。为了使跳跃的次数尽可能地少，应该选择离最后面这个点最远的那个满足要求的点。因此，考虑使用从左向右，依次检查是否有能够一次到达最后一点的点。找到了之后，再以这个点作为最末尾的点，依然从左向右找到第一个能够到达这个点的下标。最终，累加计算的cnt即为所求。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(pos&gt;<span class="number">0</span>)&#123; <span class="comment">//控制pos从下标0开始，结束循环时pos刚好=0</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[i]+i&gt;=pos)&#123;</span><br><span class="line">                        pos=i;</span><br><span class="line">                        cnt++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2022-10-16-最大子序列和"><a href="#2022-10-16-最大子序列和" class="headerlink" title="2022-10-16 最大子序列和"></a>2022-10-16 最大子序列和</h3><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组是数组中的一个连续部分。</p><p>示例 1：<br>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。<br>示例 2：<br>输入：nums = [1]<br>输出：1<br>示例 3：<br>输入：nums = [5,4,-1,7,8]<br>输出：23<br> <br>提示：<br>1 &lt;= nums.length &lt;= 105<br>-104 &lt;= nums[i] &lt;= 104</p><p>解题思路：<br>设f(i)为以第i个数结尾的连续子数组的最大和。对于数组中的每一个元素，考虑这个数是单独作为一个子序列还是加入前面的f(i-1)函数段。设prev为当前的最优选择的最大和，得到状态转移方程为：<br>prev=max{f(i-1)+nums[i],f(i)}</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [] dp= <span class="keyword">new</span> <span class="title class_">int</span> [nums.length];</span><br><span class="line">          <span class="comment">//dp[i]：表示以 nums[i] 结尾 的 连续 子数组的最大和。</span></span><br><span class="line">        <span class="type">int</span> res=nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i-<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;    <span class="comment">//前一个数的最大子序列和大于0，说明对于以当前数为末尾的子序列最大和为当前数加上nums[i]</span></span><br><span class="line">                dp[i]=dp[i-<span class="number">1</span>]+nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">//否则，对nums[i]来说，当前最大的子序列是自己单成一个子序列</span></span><br><span class="line">                dp[i]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;res)&#123;</span><br><span class="line">                res=dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> prev=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            prev=Math.max(prev+nums[i],nums[i]); <span class="comment">//判断当前数字是单独成为一段还是加入前面的f(i-1)</span></span><br><span class="line">            max=Math.max(prev,max); <span class="comment">//每次更新当前最大的子序列和的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2022-10-18"><a href="#2022-10-18" class="headerlink" title="2022-10-18"></a>2022-10-18</h3><p>给定一个长度为 n 的环形整数数组 nums ，返回 nums 的非空 子数组 的最大可能和 。<br>环形数组 意味着数组的末端将会与开头相连呈环状。形式上， nums[i] 的下一个元素是 nums[(i + 1) % n] ， nums[i] 的前一个元素是 nums[(i - 1 + n) % n] 。<br>子数组最多只能包含固定缓冲区 nums 中的每个元素一次。形式上，对于子数组 nums[i], nums[i + 1], …, nums[j] ，不存在 i &lt;= k1, k2 &lt;= j 其中 k1 % n == k2 % n 。</p><p>示例 1：<br>输入：nums = [1,-2,3,-2]<br>输出：3<br>解释：从子数组 [3] 得到最大和 3<br>示例 2：<br>输入：nums = [5,-3,5]<br>输出：10<br>解释：从子数组 [5,5] 得到最大和 5 + 5 = 10<br>示例 3：<br>输入：nums = [3,-2,2,-3]<br>输出：3<br>解释：从子数组 [3] 和 [3,-2,2] 都可以得到最大和 3<br> <br>提示：<br>n == nums.length<br>1 &lt;= n &lt;= 3 * 104<br>-3 * 104 &lt;= nums[i] &lt;= 3 * 104​​​​​​​</p><p>解题思路：<br>来自评论区大神————直接两种情况。<br>1：最大数组和在中间，和平时一样解法<br>2：最大数组和是跨越头尾，回头了，从两边出发往中间靠拢必须都是最大，那就说明中间段就是最小，找最小不就行了。</p><p>比官方解题好太多啊啊啊啊！！！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubarraySumCircular</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> prev=<span class="number">0</span>,max=nums[<span class="number">0</span>],sum=<span class="number">0</span>,min=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            prev=Math.max(nums[i]+prev,nums[i]);</span><br><span class="line">            max=Math.max(prev,max);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prev=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            prev=Math.min(prev+nums[i],nums[i]);</span><br><span class="line">            min=Math.min(prev,min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(max,sum-min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2022-10-23-杨辉三角"><a href="#2022-10-23-杨辉三角" class="headerlink" title="2022-10-23 杨辉三角"></a>2022-10-23 杨辉三角</h3><p>给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。<br>在「杨辉三角」中，每个数是它左上方和右上方的数的和。<br>示例 1:</p><p>输入: numRows = 5<br>输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]<br>示例 2:<br>输入: numRows = 1<br>输出: [[1]]</p><p>提示:</p><p>1 &lt;= numRows &lt;= 30</p><p>解题思路：很简单，找到上一行相应列和前一列的和。</p><p>具体代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">generate</span><span class="params">(<span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numRows;i++)&#123;</span><br><span class="line">            List&lt;Integer&gt; row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>||j==i)&#123;</span><br><span class="line">                    row.add(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    row.add(res.get(i-<span class="number">1</span>).get(j)+res.get(i-<span class="number">1</span>).get(j-<span class="number">1</span>)); <span class="comment">//add里写的应该是res，前面行的记录都在res里，row只有当前行的数字</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2022-10-23-杨辉三角Ⅱ"><a href="#2022-10-23-杨辉三角Ⅱ" class="headerlink" title="2022-10-23 杨辉三角Ⅱ"></a>2022-10-23 杨辉三角Ⅱ</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。<br>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><p>示例 1:<br>输入: rowIndex = 3<br>输出: [1,3,3,1]<br>示例 2:<br>输入: rowIndex = 0<br>输出: [1]<br>示例 3:<br>输入: rowIndex = 1<br>输出: [1,1]<br>显然这不是最好解法，内存消耗太大。。。</p><h4 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getRow</span><span class="params">(<span class="type">int</span> rowIndex)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=rowIndex;i++)&#123;</span><br><span class="line">            List&lt;Integer&gt; row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>||j==i)&#123;</span><br><span class="line">                    row.add(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    row.add(res.get(i-<span class="number">1</span>).get(j-<span class="number">1</span>)+res.get(i-<span class="number">1</span>).get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.get(rowIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2022-10-23-买股票的最佳时机"><a href="#2022-10-23-买股票的最佳时机" class="headerlink" title="2022-10-23 买股票的最佳时机"></a>2022-10-23 买股票的最佳时机</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p>示例 1：<br>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br>示例 2：<br>输入：prices = [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</p><p>提示：<br>1 &lt;= prices.length &lt;= 105<br>0 &lt;= prices[i] &lt;= 104</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>暴力求解，搞了半天但是超出时间范围，还以为哪错了。。。。<br>省时间的方法是，只遍历一次。如果是在历史最低点买入的股票，考虑如果今天卖掉会赚多少钱。所以在这次遍历的过程中，一边更新历史最低点的值，一边更新可以赚到的钱。（同时更新是否会造成延迟？不会的，因为卖出总是在买入之后）<br>长个记性，小心超时啊啊啊啊。</p><h4 id="具体代码-1"><a href="#具体代码-1" class="headerlink" title="具体代码"></a>具体代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> min=Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxprofit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&lt;min)&#123;</span><br><span class="line">                min=prices[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(prices[i]-min&gt;maxprofit)&#123;</span><br><span class="line">                maxprofit=prices[i]-min;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2022-10-26-比特位计数"><a href="#2022-10-26-比特位计数" class="headerlink" title="2022-10-26 比特位计数"></a>2022-10-26 比特位计数</h3><p>给你一个整数 n ，对于 0 &lt;= i &lt;= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。</p><p>示例 1：<br>输入：n = 2<br>输出：[0,1,1]<br>解释：<br>0 –&gt; 0<br>1 –&gt; 1<br>2 –&gt; 10<br>示例 2：</p><p>输入：n = 5<br>输出：[0,1,1,2,1,2]<br>解释：<br>0 –&gt; 0<br>1 –&gt; 1<br>2 –&gt; 10<br>3 –&gt; 11<br>4 –&gt; 100<br>5 –&gt; 101<br> <br>提示：</p><p>0 &lt;= n &lt;= 105</p><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><p>对于所有的数字，只有两类：</p><p>奇数：二进制表示中，奇数一定比前面那个偶数多一个 1，因为多的就是最低位的 1。<br>          举例：<br>         0 = 0       1 = 1<br>         2 = 10      3 = 11<br>偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的。<br>           举例：<br>          2 = 10       4 = 100       8 = 1000<br>          3 = 11       6 = 110       12 = 1100<br>另外，0 的 1 个数为 0，于是就可以根据奇偶性开始遍历计算了</p><h4 id="方法二-Brian-Kernighan算法"><a href="#方法二-Brian-Kernighan算法" class="headerlink" title="方法二 Brian Kernighan算法"></a>方法二 Brian Kernighan算法</h4><p><strong>目的：判断一个数字n的比特位中1的个数</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    x&amp;=(x-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如8&amp;7：将8和7写成二进制形式。1000和111，按位取与操作之后直接变成0，循环进行了一次，即8的二进制只有一个1。<br>例如7&amp;6：写成二进制形式，111和110，按位取与之后变成110；接着110&amp;101，按位取与之后变成100；接着100&amp;011，按位取与之后变成0。循环结束，一共进行了三次，故7的二进制表达式中有3个1。</p><h4 id="具体代码-2"><a href="#具体代码-2" class="headerlink" title="具体代码"></a>具体代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一 奇数偶数分类讨论</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] countBits(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        ans[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>)&#123; <span class="comment">//如果为奇数，则1的个数比前面偶数1的个数多1</span></span><br><span class="line">                ans[i]=ans[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">//如果为偶数，则1的个数是这个偶数/2的1的个数</span></span><br><span class="line">                ans[i]=ans[i/<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二 Brian Kernighan算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] countBits(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        ans[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x=i;</span><br><span class="line">            <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                x&amp;=(x-<span class="number">1</span>);</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2022-10-27-判断子序列"><a href="#2022-10-27-判断子序列" class="headerlink" title="2022-10-27 判断子序列"></a>2022-10-27 判断子序列</h4><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。<br>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p><p>示例 1：<br>输入：s = “abc”, t = “ahbgdc”<br>输出：true<br>示例 2：<br>输入：s = “axc”, t = “ahbgdc”<br>输出：false</p><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>采用双指针，一个控制原序列t的位置，另一个控制子序列s的位置。前往后匹配，可以发现每次贪心地匹配靠前的字符是最优决策。如果在原序列里成功找到了子序列的最后一个字符，返回true；如果到原序列最后一个字符也还没完全匹配到子序列，则返回false。另外，如果子序列为空，直接返回true。</p><h4 id="具体代码-3"><a href="#具体代码-3" class="headerlink" title="具体代码"></a>具体代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> lens=s.length();</span><br><span class="line">        <span class="type">int</span> lent=t.length();</span><br><span class="line">        <span class="keyword">if</span>(lens==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=lent-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">if</span>(j==lens)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2022-10-27-5-最长回文串"><a href="#2022-10-27-5-最长回文串" class="headerlink" title="2022-10-27 5.最长回文串"></a>2022-10-27 5.最长回文串</h3><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><p>示例 1：<br>输入：s = “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。<br>示例 2：<br>输入：s = “cbbd”<br>输出：”bb”</p><p>提示：<br>1 &lt;= s.length &lt;= 1000<br>s 仅由数字和英文字母组成</p><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p><code>s[i...j]</code>长度为<code>L=j-i+1</code><br>状态转移方程：<br>只有<code>s[i+1:j-1]</code>是回文串，并且s的第i和j个字母相同时，<code>s[i:j]</code>才会是回文串。<br>边界条件：<br>P(i,i)==true;<br>P(i,i+1)=(Si==S(i+1))</p><h4 id="具体代码-4"><a href="#具体代码-4" class="headerlink" title="具体代码"></a>具体代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> maxLen=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> begin=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//dp[i][j] 表示s[i...j]是否为回文串</span></span><br><span class="line">        <span class="type">boolean</span> dp[][] = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">        <span class="comment">//初始化，所有长度为1的子串都是回文串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            dp[i][i]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] charArray=s.toCharArray();</span><br><span class="line">        <span class="comment">//递推开始，先枚举子串长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> L=<span class="number">2</span>;L&lt;=len;L++)&#123;</span><br><span class="line">            <span class="comment">//枚举左边界</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                <span class="comment">//由L和i确定右边界  j-i+1=L （L为子串长度）</span></span><br><span class="line">                <span class="type">int</span> j=L+i-<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//如果右边界越界，直接退出当前循环</span></span><br><span class="line">                <span class="keyword">if</span>(j&gt;=len)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(charArray[i]!=charArray[j])&#123;</span><br><span class="line">                    dp[i][j]=<span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//s[i]&amp;s[j]相等</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//s[i...j]长度&lt;3,为1或2，那么一定为回文串</span></span><br><span class="line">                    <span class="keyword">if</span>(j-i&lt;<span class="number">3</span>)&#123;</span><br><span class="line">                        dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//s[i...j]长度&gt;3，是不是回文串要看s[i+1...j-1]是不是回文串</span></span><br><span class="line">                        dp[i][j]=dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文</span></span><br><span class="line">                <span class="comment">//此时记录回文长度和起始位置，并与maxLen比较</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]&amp;&amp;j-i+<span class="number">1</span>&gt;maxLen)&#123;</span><br><span class="line">                    maxLen=j-i+<span class="number">1</span>;</span><br><span class="line">                    begin=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//截取最大回文子串的起始到截止位置</span></span><br><span class="line">        <span class="keyword">return</span> s.substring(begin,begin+maxLen);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2022-11-1-乘积最大子数组"><a href="#2022-11-1-乘积最大子数组" class="headerlink" title="2022-11-1 乘积最大子数组"></a>2022-11-1 乘积最大子数组</h3><p>给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。<br>测试用例的答案是一个 32位 整数。<br>子数组 是数组的连续子序列。</p><p>示例 1:<br>输入: nums = [2,3,-2,4]<br>输出: 6<br>解释: 子数组 [2,3] 有最大乘积 6。<br>示例 2:<br>输入: nums = [-2,0,-1]<br>输出: 0<br>解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</p><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>一开始，想到的是【最大子序和】的方法，即dp[i]=max(dp[i-1]*nums[i],nums[i])。要么单独成为一个子数组，要么加入前面dp[i-1]对应的一段。在这两种情况之中取最大值，求出所有的dp[i]之后选最大的为答案。<br>但是这是不对的。因为这个题不满足最优子结构。</p><p>如果 a={5,6,−3,4,−3}，此时dp[i]={5,30,-3,4,-3}。按照最大子序和的算法，答案应为30。但是实际上这个题的答案是全体数字的乘积。</p><p>之所以出现这种问题，原因在于最后一个-3所对应的dp[i]的值不是-3，而是5x6x(-3)x4x(-3)=30.由此，得到结论：<strong>当前位置的最优解未必是由前一个位置的最优解转移得到的。</strong></p><p>之后，考虑对正负性进行分类讨论。</p><p>如果当前元素是负数，希望以其钱一个位置结尾的某个段的积也是负数，从而负负得正，要求这个积尽可能地小（Z作为负数）。<br>如果当前元素是正数，希望以其前一个位置结尾的某个段的积也是正数，并希望他尽可能的大。</p><p>于是，需要维护两个数组，一个表示以i个元素结尾的乘积最小子数组的乘积，一个是最大子数组的乘积。得到如下动态转移方程。</p><p>maxnum[i]=max(maxnum[i-1]xnums[i],minnum[i-1]xnums[i],nums[i])<br>minnum[i]=min(maxnum[i-1]xnums[i],minnum[i-1]xnums[i],nums[i])</p><p>最后，在maxnum数组里挑一个最大的就是最后结果。</p><h3 id="具体代码-5"><a href="#具体代码-5" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] maxnum = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span>[] minnum = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="comment">//初始化数组</span></span><br><span class="line">        maxnum[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        minnum[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            maxnum[i]=Math.max(maxnum[i-<span class="number">1</span>]*nums[i],Math.max(nums[i],minnum[i-<span class="number">1</span>]*nums[i]));<span class="comment">//考虑把nums[i]加入以nums[i-1]结尾的乘积最大或最小子数组的乘积中，三者加上nums[i]自成一段，选一个最大的</span></span><br><span class="line">            </span><br><span class="line">            minnum[i]=Math.min(maxnum[i-<span class="number">1</span>]*nums[i],Math.min(nums[i],minnum[i-<span class="number">1</span>]*nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历数组找一个最大的作为答案</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> maxnum[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maxnum[i]&gt;res)&#123;</span><br><span class="line">                res = maxnum[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间/空间复杂度均为O(n)</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习笔记</title>
      <link href="/2022/09/29/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/09/29/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux学习笔记（摸索ing）"><a href="#Linux学习笔记（摸索ing）" class="headerlink" title="Linux学习笔记（摸索ing）"></a>Linux学习笔记（摸索ing）</h1><h2 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h2><h3 id="管道函数"><a href="#管道函数" class="headerlink" title="管道函数"></a>管道函数</h3><p>创建管道可以通过调用 pipe()来实现。</p><ul><li>所需头文件：<code>#include &lt;unistd.h&gt;</code></li><li>函数原型：<code>int pipe(int fd[2])</code></li><li>函数传入：<code>fd[2]</code>：管道的两个文件描述符，pipe之后就可以直接操作这两个文件描述符</li><li>返回值：成功0，错误-1</li></ul><h2 id="Linux命令大全"><a href="#Linux命令大全" class="headerlink" title="Linux命令大全"></a>Linux命令大全</h2><p>常见命令<br>ls/cd/pwd<br>mkdir/rmdir<br>cp/rm/mv<br>tar/zip/unzip<br>ln…</p><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><p>linux系统文件夹644、755、777权限设置 ，从左至右，第一位数字代表文件所有者的权限，第二位数字代表同组用户的权限，第三位数字代表其他用户的权限。</p><table><thead><tr><th align="center">位数</th><th align="center">权限对象</th></tr></thead><tbody><tr><td align="center">左1</td><td align="center">文件所有者</td></tr><tr><td align="center">左2</td><td align="center">同组用户</td></tr><tr><td align="center">左3</td><td align="center">其他用户</td></tr></tbody></table><p>而具体的权限是由数字来表示的，读取的权限等于4，用r表示；写入的权限等于2，用w表示；执行的权限等于1，用x表示；</p><p><strong>通过4、2、1的组合，得到以下几种权限：0（没有权限）；4（读取权限）；5（4+1 | 读取+执行）；6（4+2 | 读取+写入）；7（4+2+1 | 读取+写入+执行）</strong></p><table><thead><tr><th align="center">权限数字</th><th align="center">权限名称</th><th align="center">对应的权限</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">—</td><td align="center">没有权限</td></tr><tr><td align="center">4</td><td align="center">r–</td><td align="center">读取</td></tr><tr><td align="center">5</td><td align="center">r-x</td><td align="center">读取+执行</td></tr><tr><td align="center">6</td><td align="center">rw-</td><td align="center">读取+写入</td></tr><tr><td align="center">7</td><td align="center">rwx</td><td align="center">读取+写入+执行</td></tr></tbody></table><p>以755为例：</p><p>第一位7等于4+2+1，rwx，所有者具有读取、写入、执行权限；</p><p>第二位5等于4+1+0，r-x，同组用户具有读取、执行权限但没有写入权限；</p><p>第三位5，同上，也是r-x，其他用户具有读取、执行权限但没有写入权限。</p><h3 id="文件列表"><a href="#文件列表" class="headerlink" title="文件列表"></a>文件列表</h3><ol><li>ls 以详细样式查看<br>ls -l /home/charyeon 展示home/charyeon目录下文件（包括文件属性）</li></ol><h3 id="切换目录"><a href="#切换目录" class="headerlink" title="切换目录"></a>切换目录</h3><ol><li>pwd print working directory显示当前位置</li><li>cd change direcotry切换目录<br>cd /home/charyeon/example<br>cd ~ 切换到主目录<br>cd ./example切换到当前目录<br>cd .. 切换到上级目录<br>cd ~/example 切换到主目录下的example目录<br>cd ../www 切换到上级目录，再到www子目录<br>ls ~<br>ls ./www </li></ol><p><strong>几个特殊的目录</strong><br>  ~ 代表当前用户的主目录<br>  . 代表当前目录<br>  .. 代表上一级目录</p><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><ol><li><p>mkdir make directory<br>mkdir abc<br>mkdir -p abc/123/test<br>设置-p参数，将路径的层次全部创建</p></li><li><p>rmdir remove directory<br>rmdir abc<br>如果目录非空，则删除失败</p></li><li><p>rm remove删除文件或者目录<br>rm -rf abc<br>删除abc目录，连带着子项一起删除<br>r：recursive，f：force</p></li><li><p>cp copy复制文件或目录<br>cp -rf example example2<br>复制example并命名为example2</p></li><li><p>mv move移动文件或目录（重命名）<br>move hello helloworld<br>把hello重命名为helloworld</p></li></ol><h3 id="归档"><a href="#归档" class="headerlink" title="归档"></a>归档</h3><ol><li><p>tar tape archive 档案打包<br>tar -cvf example.tar example 把example打包从成example.tar<br>c：create 创建档案<br>v：verbose 显示详情<br>f：file<br>也可以多个目录打包 tar -cvf xxx.tar file1 file2 file3</p></li><li><p>还原档案包<br>tar -xvf example.tar<br>tar -xvf example.tar -C outdir<br>x：extract -C参数指定目标目录，默认解到当前目录下<br>以上两个操作只是归档但没有压缩，文件依然会比较大</p></li><li><p>归档并压缩<br>tar -zcvf example.tar.gz example<br>tar -zxvf example.tar.gz<br>tar -zxvf example.tar.gz -C outdir<br>通常见到的都为*.tar.gz格（标准压缩包格式）</p></li></ol><h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><p>  即Windows下的快捷方式，使用ln（link）命令来创建软链接<br>  ln -s source link<br>  -s：表示soft软链接（默认为硬）<br>  ln -s example example2</p><p>软链接的特点：</p><ol><li>删除软链接对原文件无影响</li><li>删除源文件则软链接失效</li></ol><p>  以 ls -l查看文件详情使可以看到目标路径（快捷方式指向文件）<br>  例如bin是usr/bin的软链接</p><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><ol><li>添加一个用户<br>sudo useradd -m test1<br>sudo：以管理员身份执行</li></ol><p>-m：表示在/home下添加用户目录</p><ol start="2"><li><p>修改密码<br>sudo passwd test1</p></li><li><p>删除用户<br>sudo userdel test1<br>sudo rm -rf /home/test1/ 同时删除主目录下的用户<br>只有特殊用户可执行sudo，把这种用户称为sudoer</p></li></ol><h3 id="超级用户"><a href="#超级用户" class="headerlink" title="超级用户"></a>超级用户</h3><p>超级用户root，类似于Windows系统下的Adminstrator用户。切换到root用户有全部权限，可以直接使用useradd等命令。</p><ol><li><p>首次使用需要给root设置密码<br>sudo passwd root</p></li><li><p>切换到root用户<br>su root 仅对当前会话终端有效，不影响当前桌面环境<br>su：switch user</p></li><li><p>退出<br>exit</p></li></ol><h3 id="用户和组"><a href="#用户和组" class="headerlink" title="用户和组"></a>用户和组</h3><p>Linux下可以创建多个用户，用组进行管理用户，每个组有不同的权限。一般用户不多的时候，不太使用组的概念。默认创建一个用户时会创建一个同名的组，也就是说默认这个组里只有他一个人。<br>比如划分为男生组boys【含ming bo gang qiang】，女生组girls【含fang hong yue yuan】。</p><ol><li><p>创建组<br>groupadd boys</p></li><li><p>创建用户<br>useradd -m -g boys ming</p></li></ol><p>-g：添加用户，并将用户加到boys组</p><ol start="3"><li><p>修改用户组别<br>usermod -g boys charyeon<br>mod：modified简称</p></li><li><p>查看用户和组<br>cat /etc/group<br>每一行表示一个group的信息，名称+ID</p></li><li><p>查看用户列表<br>cat /etc/passwd<br>每一行表示一个用户的信息</p></li></ol><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><ul><li>owner：文件的属主</li><li>r：文件是否可读</li><li>w：文件是否可写</li><li>x：文件是否可执行</li></ul><p>使用 Linux 时，通过命令行输入 ls -l / 可以看到，在 Linux 根目录（/）下包含很多的子目录（称为一级目录），例如 bin、boot、dev 等。同时，各一级目录下还含有很多子目录（称为二级目录），比如 /bin/bash、/bin/ed 等。Linux 文件系统目录总体呈现树形结构，/ 根目录就相当于树根。<br>为了避免诸多使用者对 Linux 系统目录结构天马行空，Linux 基金会发布了 FHS 标准。多数 Linux 发行版系统都遵循这一标准。<br>FHS（Filesystem Hierarchy Standard），文件系统层次化标准，该标准规定了 Linux 系统中所有一级目录以及部分二级目录（/usr 和 /var）的用途。发布此标准的主要目的就是为了让用户清楚地了解每个目录应该存放什么类型的文件。</p><h3 id="查看邮件"><a href="#查看邮件" class="headerlink" title="查看邮件"></a>查看邮件</h3><p>查看邮件 mail<br>显示当前邮件 p<br>显示标号为1的邮件 1<br>退出邮箱不保存之前的操作 x<br>退出游戏保存之前操作 q</p><h2 id="Linux根目录（-）"><a href="#Linux根目录（-）" class="headerlink" title="Linux根目录（/）"></a>Linux根目录（/）</h2><p>Linux 系统的根目录（/）最为重要，包含开机软件、核心文件、开机所需程序、函数库、修复系统程序等文件。</p><ul><li>/bin/<br>存放系统命令，普通用户和 root 都可以执行。放在 /bin 下的命令在单用户模式下也可以执行</li><li>/boot/<br>系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序（grub）文件等</li><li>/dev/<br>设备文件保存位置</li><li>/etc/<br>配置文件保存位置。系统内所有采用默认安装方式（rpm 安装）的服务配置文件全部保存在此目录中，如用户信息、服务的启动脚本、常用服务的配置文件等</li><li>/home/<br>普通用户的主目录（也称为家目录）。在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的主目录，所有普通用户的主目录是在 /home/ 下建立一个和用户名相同的目录。如用户 Jupiter 的主目录就是 /home/Jupiter</li><li>/lib/<br>系统调用的函数库保存位置</li><li>/media/<br>挂载目录。系统建议用来挂载媒体设备，如软盘和光盘</li><li>/mnt/<br>挂载目录。早期 Linux 中只有这一个挂载目录，并没有细分。系统建议这个目录用来挂载额外的设备，如 U 盘、移动硬盘和其他操作系统的分区</li><li>/misc/<br>挂载目录。系统建议用来挂载 NFS 服务的共享目录。虽然系统准备了三个默认挂载目录 /media/、/mnt/、/misc/，但是到底在哪个目录中挂载什么设备可以由管理员自己决定。例如，参考者在接触 Linux 的时候，默认挂载目录只有 /mnt/，所以养成了在 /mnt/ 下建立不同目录挂载不同设备的习惯，如 /mnt/cdrom/ 挂载光盘、/mnt/usb/ 挂载 U 盘，都是可以的</li><li>/opt/<br>第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。不过/usr/local/ 目录也可以用来安装软件</li><li>/root/<br>root 的主目录。普通用户主目录在 /home/ 下，root 主目录直接在“/”下</li><li>/sbin/<br>保存与系统环境设置相关的命令，只有 root 可以使用这些命令进行系统环境设置，但也有些命令可以允许普通用户查看</li><li>/srv/<br>服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据</li><li>/tmp/<br>临时目录。系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入。建议此目录中不能保存重要数据，最好每次开机都把该目录清空。</li></ul><h2 id="Linux-usr目录"><a href="#Linux-usr目录" class="headerlink" title="Linux /usr目录"></a>Linux /usr目录</h2><p>usr，全称为 Unix Software Resource，此目录用于存储系统软件资源。FHS 建议所有开发者，应把软件产品的数据合理的放置在 /usr 目录下的各子目录中，而不是为他们的产品创建单独的目录。<br>Linux 系统中，所有系统默认的软件都存储在 /usr 目录下，/usr 目录类似 Windows 系统中 C:\Windows\ + C:\Program files\ 两个目录的综合体。<br>FHS 建议，/usr 目录应具备表 3 所示的子目录。</p><ul><li>/usr/bin/<br>存放系统命令，普通用户和超级用户都可以执行。这些命令和系统启动无关，在单用户模式下不能执行。</li><li>/usr/sbin/<br>存放根文件系统不必要的系统管理命令，如多数服务程序，只有 root 可以使用。</li><li>/usr/lib/<br>应用程序调用的函数库保存位置</li><li>/usr/XllR6/<br>图形界面系统保存位置</li><li>/usr/local/<br>手工安装的软件保存位置。一般建议源码包软件安装在这个位置。</li><li>/usr/share/<br>应用程序的资源文件保存位置，如帮助文档、说明文档和字体目录。</li><li>/usr/src/<br>源码包保存位置。我们手工下载的源码包和内核源码包都可以保存到这里。不过一般更习惯把手工下载的源码包保存到 /usr/local/src/ 目录中，把内核源码保存到 /usr/src/linux/ 目录中</li><li>/usr/include<br>C/C++ 等编程语言头文件的放置目录</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora学习笔记</title>
      <link href="/2022/09/05/Typora%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2022/09/05/Typora%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一-文字处理"><a href="#一-文字处理" class="headerlink" title="一.文字处理"></a>一.文字处理</h1><ol><li><strong>标题</strong> 标题一共有六级,是用“#”实现的，标题前面加一个“#”，代表一级标题；依次类推，标题前面加六个“#”代表六级标题；一共有六级标题，编辑各种文档完全够用,左侧的目录会根据输入的标题自动生成响应的层级。</li><li><strong>强调</strong> 在要强调内容前后分别加两个“*”号。</li><li><strong>斜体</strong> 前后分别加一个“*”号。</li><li><strong>删除线</strong> 内容前后分别加上两个“~”号。</li><li><strong>分割线</strong> 输入三个或三个以上“-”（“*”），再按回车键，即出现一条分割线。</li><li><strong>插入</strong> 插入本地图片：直接把图片拖入即可； 插入网络图片：![图片标题]（图片链接）<br>选择本地文件或者输入url地址都可以。</li><li><strong>链接</strong> [链接提示]+(链接地址)</li><li><strong>数学公式</strong> “$$”+回车。</li><li><strong>代码</strong><br>行内代码：代码的两端各加一个“`”号，（在Tab键上面，英文输入法）。<br>代码块：输入三个“~”，按回车键，即可选择编程语言。</li></ol><h1 id="二-list列表处理"><a href="#二-list列表处理" class="headerlink" title="二.list列表处理"></a>二.list列表处理</h1><ol><li><strong>有序列表</strong> 输入数字“1”+“.”+空格 ， 自动开始有序列表。</li><li><strong>无序列表</strong>输入“+”或“-”或“*”+空格，自动开始无序列表。</li><li><strong>table表格</strong> Ctrl+T,在弹出的对话框中选择行列数，自动生成列表。 还可以很方便地对表格进行编辑。当然还有另外一种建立表格的方式用’|’分隔然后回车创建表格（首尾都需要添加）,使用ctrl+回车新添一行。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git报错合集【持续更新···】</title>
      <link href="/2022/08/22/git%E6%97%B6%E6%8A%A5%E9%94%99/"/>
      <url>/2022/08/22/git%E6%97%B6%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<h1 id="Git报错合集"><a href="#Git报错合集" class="headerlink" title="Git报错合集"></a>Git报错合集</h1><h2 id="OpenSSL-SSL-connect-Connection-was-reset-in-connection-to-git-com-443"><a href="#OpenSSL-SSL-connect-Connection-was-reset-in-connection-to-git-com-443" class="headerlink" title="OpenSSL SSL_connect: Connection was reset in connection to git.com:443"></a>OpenSSL SSL_connect: Connection was reset in connection to git.com:443</h2><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>使用git进行pull和push时，报错如下：</p><p>OpenSSL SSL_connect: Connection was reset in connection to git.com:443</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在git bash中输入以下命令：<br>(第二个命令双引号内路径换成git安装路径)</p><pre><code>git config --global http.sslBackend &quot;openssl&quot;git config --global http.sslCAInfo &quot;D:\software\Git\mingw64\ssl\cert.pem&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Git </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常见问题 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Nunjucks Error:问题原因及解决</title>
      <link href="/2022/08/18/Hexo-Nunjucks-Error-%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
      <url>/2022/08/18/Hexo-Nunjucks-Error-%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>在学习开发小程序过程中，记录了一些内容。随后，尝试hexo s，但是出现如下报错：</p><img src="/2022/08/18/Hexo-Nunjucks-Error-%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3/Nunjunks.png" class="" title="报错"><p>改了半天，发现是"{{}}"有问题：<img src="/2022/08/18/Hexo-Nunjucks-Error-%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3/Nunjunks2.png" class="" title="报错">解决方法如下：将"{{}}"替换为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% raw %&#125;&quot;&#123;&#123;&#125;&#125;&quot;&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
          <category> 问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序开发随记</title>
      <link href="/2022/08/18/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%9A%8F%E8%AE%B0/"/>
      <url>/2022/08/18/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%9A%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="微信小程序开发随记"><a href="#微信小程序开发随记" class="headerlink" title="微信小程序开发随记"></a>微信小程序开发随记</h1><p>目前主要是参考了官方文档</p><h2 id="小程序代码构成"><a href="#小程序代码构成" class="headerlink" title="小程序代码构成"></a>小程序代码构成</h2><p>首先去官方申请小程序账号，然后安装开发者工具，新建项目；之后，会发现项目里自动生成了不同类型的文件。</p><ol><li>.json 后缀的 JSON 配置文件</li><li>.wxml 后缀的 WXML 模板文件</li><li>.wxss 后缀的 WXSS 样式文件</li><li>.js 后缀的 JS 脚本逻辑文件</li></ol><h3 id="JSON-配置"><a href="#JSON-配置" class="headerlink" title="JSON 配置"></a>JSON 配置</h3><p>JSON 是一种数据格式，并不是编程语言，在小程序中，JSON扮演的静态配置的角色。我们可以看到在项目的根目录有一个 <strong>app.json</strong> 和 <strong>project.config.json</strong>，此外在 <strong>pages/logs</strong> 目录下还有一个 <strong>logs.json</strong>，我们依次来说明一下它们的用途。</p><h4 id="小程序配置-app-json"><a href="#小程序配置-app-json" class="headerlink" title="小程序配置 app.json"></a>小程序配置 app.json</h4><p><strong>app.json</strong> 是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。QuickStart 项目里边的 <strong>app.json</strong> 配置内容如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;pages&quot;</span>:[</span><br><span class="line">    <span class="string">&quot;pages/index/index&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pages/logs/logs&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;window&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;backgroundTextStyle&quot;</span>:<span class="string">&quot;light&quot;</span>,</span><br><span class="line">    <span class="string">&quot;navigationBarBackgroundColor&quot;</span>: <span class="string">&quot;#fff&quot;</span>,</span><br><span class="line">    <span class="string">&quot;navigationBarTitleText&quot;</span>: <span class="string">&quot;Weixin&quot;</span>,</span><br><span class="line">    <span class="string">&quot;navigationBarTextStyle&quot;</span>:<span class="string">&quot;black&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个配置各个项的含义:</p><ol><li>pages字段：描述当前小程序所有页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录。</li><li>window字段：定义小程序所有页面的顶部背景颜色，文字颜色定义等。</li></ol><h4 id="工具配置-project-config-json"><a href="#工具配置-project-config-json" class="headerlink" title="工具配置 project.config.json"></a>工具配置 project.config.json</h4><p>通常大家在使用一个工具的时候，都会针对各自喜好做一些个性化配置，例如界面颜色、编译配置等等，当你换了另外一台电脑重新安装工具的时候，你还要重新配置。</p><p>考虑到这点，小程序开发者工具在每个项目的根目录都会生成一个 <strong>project.config.json</strong>，你在工具上做的任何配置都会写入到这个文件，当你重新安装工具或者换电脑工作时，你只要载入同一个项目的代码包，开发者工具就自动会帮你恢复到当时你开发项目时的个性化配置，其中会包括编辑器的颜色、代码上传时自动压缩等等一系列选项。</p><h4 id="页面配置-page-json"><a href="#页面配置-page-json" class="headerlink" title="页面配置 page.json"></a>页面配置 page.json</h4><p>这里的 <strong>page.json</strong> 其实用来表示 pages/logs 目录下的 <strong>logs.json</strong> 这类和小程序页面相关的配置。</p><p>如果你整个小程序的风格是蓝色调，那么你可以在 app.json 里边声明顶部颜色是蓝色即可。实际情况可能不是这样，可能你小程序里边的每个页面都有不一样的色调来区分不同功能模块，因此我们提供了 page.json，让开发者可以独立定义每个页面的一些属性，例如刚刚说的顶部颜色、是否允许下拉刷新等等。</p><h4 id="JSON简单语法"><a href="#JSON简单语法" class="headerlink" title="JSON简单语法"></a>JSON简单语法</h4><p>JSON文件都是被包裹在一个大括号中 {}，通过 key-value 的方式来表达数据。JSON的 Key 必须包裹在一个<strong>双引号</strong>中，在实践中，编写 JSON 的时候，忘了给 Key 值加双引号或者是把双引号写成单引号是常见错误。需要注意的是 JSON 文件中无法使用注释，试图添加注释将会引发报错。<br>JSON的值只能是以下几种数据格式，其他任何格式都会触发报错，例如 JavaScript 中的 undefined。</p><ol><li>数字，包含浮点数和整数</li><li>字符串，需要包裹在双引号中</li><li>Bool值，true 或者 false</li><li>数组，需要包裹在方括号中 []</li><li>对象，需要包裹在大括号中 {}</li><li>Null</li></ol><h3 id="WXML-模板"><a href="#WXML-模板" class="headerlink" title="WXML 模板"></a>WXML 模板</h3><p>网页编程采用的是 <strong>HTML + CSS + JS</strong> 这样的组合，其中 <strong>HTML</strong> 是用来描述当前这个页面的结构，<strong>CSS</strong> 用来描述页面的样子，<strong>JS</strong> 通常是用来处理这个页面和用户的交互。</p><p>同样道理，在小程序中也有同样的角色，其中 <strong>WXML</strong> 充当的就是类似 HTML 的角色。打开 <strong>pages/index/index.wxml</strong>，你会看到以下的内容:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;userinfo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;&quot;</span>&gt;</span> 获取头像昵称 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:else</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;userInfo.avatarUrl&#125;&#125;&quot;</span> <span class="attr">background-size</span>=<span class="string">&quot;cover&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">&quot;userinfo-nickname&quot;</span>&gt;</span>&#123;&#123;userInfo.nickName&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;usermotto&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">&quot;user-motto&quot;</span>&gt;</span>&#123;&#123;motto&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>和 <strong>HTML</strong> 非常相似，<strong>WXML</strong> 由标签、属性等等构成。但是也有很多不一样的地方，如下：</p><ol><li>标签名字不一样<br>写 <strong>HTML</strong> 的时候，经常会用到的标签是 div, p, span，开发者在写一个页面的时候可以根据这些基础的标签组合出不一样的组件，例如日历、弹窗等等。<strong>wxml</strong>中，把这些常用的组件包装了起来，提高了开发效率。<br>小程序的 <strong>WXML</strong> 用的标签是 <strong>view</strong>, <strong>button</strong>, <strong>text</strong> 等等，这些标签就是小程序给开发者包装好的基本能力，我们还提供了地图、视频、音频等等组件能力。</li><li>多了一些 <strong>wx:if</strong> 这样的属性以及 "{{}}" 这样的表达式在网页的一般开发流程中，我们通常会通过 **JS** 操作 **DOM** (对应 HTML 的描述产生的树)，以引起界面的一些变化响应用户的行为。例如，用户点击某个按钮的时候，**JS** 会记录一些状态到 **JS** 变量里边，同时通过 **DOM** API 操控 **DOM** 的属性或者行为，进而引起界面一些变化。当项目越来越大的时候，你的代码会充斥着非常多的界面交互逻辑和程序的各种状态变量，显然这不是一个很好的开发模式，因此就有了 **MVVM** 的开发模式（例如 React, Vue），提倡把渲染和逻辑分离。*简单来说就是不要再让 **JS** 直接操控 **DOM**，**JS** 只需要管理状态即可，然后再通过一种模板语法来描述状态和界面结构的关系即可。*如果你需要把一个 Hello World 的字符串显示在界面上,**WXML** 是这么写:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;text&gt;&#123;&#123;msg&#125;&#125;&lt;/text&gt;</span><br></pre></td></tr></table></figure>**JS** 只需要管理状态即可:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.setData(&#123; msg: &quot;Hello World&quot; &#125;)</span><br></pre></td></tr></table></figure>通过 "{{}}" 的语法把一个变量绑定到界面上，我们称为数据绑定。仅仅通过数据绑定还不够完整的描述状态和界面的关系，还需要 <strong>if/else</strong>, <strong>for</strong>等控制能力，在小程序里边，这些控制能力都用 <strong>wx:</strong> 开头的属性来表达。</li></ol><h3 id="WXSS-样式"><a href="#WXSS-样式" class="headerlink" title="WXSS 样式"></a>WXSS 样式</h3><p><strong>WXSS</strong> 具有 <strong>CSS</strong> 大部分的特性，小程序在 <strong>WXSS</strong> 也做了一些扩充和修改。</p><ol><li>新增了尺寸单位：在写 <strong>CSS</strong> 样式时，开发者需要考虑到手机设备的屏幕会有不同的宽度和设备像素比，采用一些技巧来换算一些像素单位。<strong>WXSS</strong> 在底层支持新的尺寸单位 <strong>rpx</strong> ，开发者可以免去换算的烦恼，只要交给小程序底层来换算即可，由于换算采用的浮点数运算，所以运算结果会和预期结果有一点点偏差。</li><li>提供了全局的样式和局部样式：和前边 <strong>app.json</strong>, <strong>page.json</strong> 的概念相同，你可以写一个 <strong>app.wxss</strong> 作为全局样式，会作用于当前小程序的所有页面，局部页面样式 <strong>page.wxss</strong> 仅对当前页面生效。</li><li>此外 <strong>WXSS</strong> 仅支持部分 <strong>CSS</strong> 选择器</li></ol><h3 id="JS-逻辑交互"><a href="#JS-逻辑交互" class="headerlink" title="JS 逻辑交互"></a>JS 逻辑交互</h3><p>一个服务仅仅只有界面展示是不够的，还需要和用户做交互：响应用户的点击、获取用户的位置等等。在小程序里边，我们就通过编写 <strong>JS</strong> 脚本文件来处理用户的操作。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">&quot;clickMe&quot;</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击 <strong>button</strong> 按钮的时候，我们希望把界面上 <strong>msg</strong> 显示成 “Hello World”，于是我们在 <strong>button</strong> 上声明一个属性: <strong>bindtap</strong> ，在 JS 文件里边声明了 <strong>clickMe</strong> 方法来响应这次点击操作：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="attr">clickMe</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123; <span class="attr">msg</span>: <span class="string">&quot;Hello World&quot;</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此外你还可以在 <strong>JS</strong> 中调用小程序提供的丰富的 API，利用这些 API 可以很方便的调起微信提供的能力，例如获取用户信息、本地存储、微信支付等。在前边的例子中，在 <strong>pages/index/index.js</strong> 就调用了 <strong>wx.getUserInfo</strong> 获取微信用户的头像和昵称，最后通过 <strong>setData</strong> 把获取到的信息显示到界面上。</p><h2 id="小程序宿主环境"><a href="#小程序宿主环境" class="headerlink" title="小程序宿主环境"></a>小程序宿主环境</h2><p>我们称微信客户端给小程序所提供的环境为宿主环境。小程序借助宿主环境提供的能力，可以完成许多普通网页无法完成的功能。</p><p>上一章中我们把小程序涉及到的文件类型阐述了一遍，我们接下来讲一下这些文件是怎么配合工作的。</p><h3 id="渲染层和逻辑层"><a href="#渲染层和逻辑层" class="headerlink" title="渲染层和逻辑层"></a>渲染层和逻辑层</h3><p>首先，我们来简单了解下小程序的运行环境。小程序的运行环境分成渲染层和逻辑层，其中 <strong>WXML</strong> 模板和 <strong>WXSS</strong> 样式工作在渲染层，<strong>JS</strong> 脚本工作在逻辑层。<br>小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了<strong>WebView</strong> 进行渲染；逻辑层采用 <strong>JsCore</strong> 线程运行 <strong>JS</strong> 脚本。一个小程序存在多个界面，所以渲染层存在多个 <strong>WebView</strong> 线程，这两个线程的通信会经由微信客户端（下文中也会采用 <strong>Native</strong> 来代指微信客户端）做中转，逻辑层发送网络请求也经由 <strong>Native</strong> 转发，小程序的通信模型下图所示：</p><img src="/2022/08/18/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%9A%8F%E8%AE%B0/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%80%9A%E4%BF%A1%E6%A8%A1%E6%9D%BF.png" class="" title="小程序通信模板"><h3 id="程序与页面"><a href="#程序与页面" class="headerlink" title="程序与页面"></a>程序与页面</h3><p>微信客户端在打开小程序之前，会把整个小程序的代码包下载到本地。<br>紧接着通过 app.json 的 pages 字段就可以知道你当前小程序的所有页面路径:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;pages&quot;</span>:[</span><br><span class="line">    <span class="string">&quot;pages/index/index&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pages/logs/logs&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置说明在项目定义了两个页面，分别位于 <strong>pages/index/index</strong> 和 <strong>pages/logs/logs</strong>。而写在 <strong>pages</strong> 字段的第一个页面就是这个小程序的首页（打开小程序看到的第一个页面）。<br>于是微信客户端就把首页的代码装载进来，通过小程序底层的一些机制，就可以渲染出这个首页。<br>小程序启动之后，在 <strong>app.js</strong> 定义的 App 实例的 onLaunch 回调会被执行:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">App</span>(&#123;</span><br><span class="line">  <span class="attr">onLaunch</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 小程序启动之后 触发</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>整个小程序只有一个 App 实例，是全部页面共享的。<br>接下来我们简单看看小程序的一个页面是怎么写的。<br>你可以观察到 <strong>pages/logs/logs</strong> 下其实是包括了4种文件的，微信客户端会先根据 <strong>logs.json</strong> 配置生成一个界面，顶部的颜色和文字你都可以在这个 json 文件里边定义好。紧接着客户端就会装载这个页面的 <strong>WXML 结构</strong>和 <strong>WXSS 样式</strong>。最后客户端会装载 <strong>logs.js</strong>，你可以看到 <strong>logs.js</strong> 的大体内容就是:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123; <span class="comment">// 参与页面渲染的数据</span></span><br><span class="line">    <span class="attr">logs</span>: []</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">onLoad</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 页面渲染后 执行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>Page</strong> 是一个页面构造器，这个构造器就生成了一个页面。在生成页面的时候，小程序框架会把 <strong>data</strong> 数据和 <strong>index.wxml</strong> 一起渲染出最终的结构，于是就得到了你看到的小程序的样子。</p><p>在渲染完界面之后，页面实例就会收到一个 <strong>onLoad</strong> 的回调，你可以在这个回调处理你的逻辑。</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>小程序提供了丰富的基础组件给开发者，开发者可以像搭积木一样，组合各种组件拼合成自己的小程序。</p><p>就像 *<strong>HTML</strong> 的 **<strong>div</strong>, <strong>p</strong> 等标签一样，在小程序里边，你只需要在 <strong>WXML</strong> 写上对应的组件标签名字就可以把该组件显示在界面上，例如，你需要在界面上显示地图，你只需要这样写即可：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;map&gt;&lt;/map&gt;</span><br></pre></td></tr></table></figure><p>使用组件的时候，还可以通过<strong>属性</strong>传递值给组件，让组件可以以不同的状态去展现，例如，我们希望地图一开始的中心的经纬度是上海，那么你需要声明地图的 longitude（中心经度） 和 latitude（中心纬度）两个属性:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;map longitude=&quot;上海经度&quot; latitude=&quot;上海纬度&quot;&gt;&lt;/map&gt;</span><br></pre></td></tr></table></figure><p>组件的内部行为也会通过事件的形式让开发者可以感知，例如用户点击了地图上的某个标记，你可以在 js 编写 markertap 函数来处理：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;map bindmarkertap=<span class="string">&quot;markertap&quot;</span> longitude=<span class="string">&quot;上海经度&quot;</span> latitude=<span class="string">&quot;上海纬度&quot;</span>&gt;&lt;/map&gt;</span><br></pre></td></tr></table></figure><p>当然你也可以通过 <strong>style</strong> 或者 <strong>class</strong> 来控制组件的外层样式，以便适应你的界面宽度高度等等。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>为了让开发者可以很方便的调起微信提供的能力，例如获取用户信息、微信支付等等，小程序提供了很多 API 给开发者去使用。<br>要获取用户的地理位置时，只需要：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wx.getLocation(&#123;</span><br><span class="line">  type: &#x27;wgs84&#x27;,</span><br><span class="line">  success: (res) =&gt; &#123;</span><br><span class="line">    var latitude = res.latitude // 纬度</span><br><span class="line">    var longitude = res.longitude // 经度</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>调用微信扫一扫能力，只需要：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wx.scanCode(&#123;</span><br><span class="line">  success: (res) =&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>需要注意的是：多数 API 的回调都是异步，你需要处理好代码逻辑的异步问题。</p><h2 id="小程序协同工作和发布"><a href="#小程序协同工作和发布" class="headerlink" title="小程序协同工作和发布"></a>小程序协同工作和发布</h2><p>多数情况下，一个团队多人同时参与同一个小程序项目，每个角色所承担的工作或者权限不一样，中大公司的分工更为仔细。为了更形象的表达团队不同角色的关系以及权限的管理，我们通过虚拟一个项目成员组织结构来描述日常如何协同合作完成一个小程序的发布，组织关系如图。</p><img src="/2022/08/18/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%9A%8F%E8%AE%B0/%E5%9B%A2%E9%98%9F%E6%9E%B6%E6%9E%84.png" class="" title="团队架构"><p><strong>项目管理</strong>成员负责统筹整个项目的进展和风险、把控小程序对外发布的节奏，<strong>产品组</strong>提出需求，<strong>设计组</strong>与产品讨论并对需求进行抽象，设计出可视化流程与图形，输出设计方案。<strong>开发组</strong>依据设计方案，进行程序代码的编写，代码编写完成后，<strong>产品组</strong>与<strong>设计组</strong>体验小程序的整体流程，<strong>测试组</strong>编写测试用例并对小程序进行各种边界测试。项目一般的成员构成与工作流程如图。</p><img src="/2022/08/18/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%9A%8F%E8%AE%B0/%E6%B5%81%E7%A8%8B.png" class="" title="小程序发布流程">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 项目 </tag>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab学习笔记</title>
      <link href="/2022/08/11/Matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/08/11/Matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>主要是为了准备数模，复习一下清风老师的课程。</p><h1 id="Matlab语法"><a href="#Matlab语法" class="headerlink" title="Matlab语法"></a>Matlab语法</h1><h2 id="一-基本小常识"><a href="#一-基本小常识" class="headerlink" title="一.基本小常识"></a>一.基本小常识</h2><h3 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h3><ol><li>a=2+3 ans=5<br>a=2+3; 无输出</li><li>多行注释 Ctrl+R</li><li>取消注释 Ctrl+T</li><li>clear可以清楚工作区的所有变量</li><li>clc可以清除命令行窗口中的所有文本</li><li>注意Matlab的数组中不能保存字符串，如果要生成字符串数组，就需要使用元胞数组，其用大括号{}定义和引用<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">ylab=&#123;<span class="string">&#x27;周数&#x27;</span>,<span class="string">&#x27;轮虫&#x27;</span>,<span class="string">&#x27;溶氧&#x27;</span>,<span class="string">&#x27;COD&#x27;</span>,<span class="string">&#x27;水温&#x27;</span>,<span class="string">&#x27;PH值&#x27;</span>,<span class="string">&#x27;盐度&#x27;</span>,<span class="string">&#x27;透明度&#x27;</span>,<span class="string">&#x27;总碱度&#x27;</span>,<span class="string">&#x27;氯离子&#x27;</span>,<span class="string">&#x27;透明度&#x27;</span>,<span class="string">&#x27;生物量&#x27;</span>&#125;;  <span class="comment">% 要画的图形的标签</span></span><br></pre></td></tr></table></figure></li><li>向量＋’表示转置</li></ol><h2 id="二-常用函数"><a href="#二-常用函数" class="headerlink" title="二.常用函数"></a>二.常用函数</h2><ol><li>输出</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;Hello Wrold!&#x27;</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>字符串合并</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%1</span></span><br><span class="line">strcat(<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;ABC&#x27;</span>)</span><br><span class="line"><span class="comment">%2</span></span><br><span class="line">[<span class="string">&#x27;abc&#x27;</span> <span class="string">&#x27;ABC&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;ABC&#x27;</span>]</span><br></pre></td></tr></table></figure><ol start="3"><li>将数字转换为字符串</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">c = <span class="number">160</span></span><br><span class="line">num2str(c)</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;c的取值为&#x27;</span>,num2str])</span><br></pre></td></tr></table></figure><ol start="4"><li>输入<br> 一般我们会将输入的数、向量、矩阵、字符串等赋给一个变量，这里我们赋给A。</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = input(<span class="string">&#x27;请输入A：&#x27;</span>);</span><br><span class="line">B = input(<span class="string">&#x27;请输入B：&#x27;</span>)</span><br></pre></td></tr></table></figure><p>加分号时，不输出结果；不加分号时，会输出B的值。</p><ol start="5"><li>sum函数<br>(1)如果是向量（无论是行向量还是列向量），都是直接求和。</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%行向量</span></span><br><span class="line">E = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">sum(E)</span><br><span class="line"><span class="comment">%列向量</span></span><br><span class="line">E = [<span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>]</span><br><span class="line">sum(E)</span><br></pre></td></tr></table></figure><p>(2)如果是矩阵，则需要根据行和列的方向作区分。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">E = [<span class="number">1</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>;<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="comment">%按列求和，得到行向量</span></span><br><span class="line">a = sum(E)</span><br><span class="line">a = sum(E,<span class="number">1</span>)</span><br><span class="line"><span class="comment">%按行求和，得到列向量</span></span><br><span class="line">a = sum(E,<span class="number">2</span>)</span><br><span class="line"><span class="comment">%对整个矩阵求和</span></span><br><span class="line">a = sum(E(:))</span><br><span class="line">a = sum(sum(E))</span><br></pre></td></tr></table></figure><ol start="6"><li><p>提取矩阵指定位置的元素</p><p> (1)取指定行和列的一个元素，输出的是一个值。</p></li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line">A(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">A(<span class="number">3</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>(2)取指定的某一行元素，输出行向量。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line"><span class="comment">% 输出第一行</span></span><br><span class="line">A(:,<span class="number">1</span>)</span><br><span class="line"><span class="comment">% 第二行</span></span><br><span class="line">A(:,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>(3)取指定的某一列的全部元素，输出列向量。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">A(<span class="number">1</span>,:)</span><br><span class="line">A(<span class="number">2</span>,:)</span><br></pre></td></tr></table></figure><p>(4)取指定的某些行的全部元素，输出矩阵</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line"></span><br><span class="line"><span class="comment">% 只取第二行和第五行（一共2行）</span></span><br><span class="line">A([<span class="number">2</span>,<span class="number">5</span>],:)</span><br><span class="line"></span><br><span class="line"> <span class="comment">% 取第二行到第五行（一共4行）</span></span><br><span class="line">A(<span class="number">2</span>:<span class="number">5</span>,:)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 取第二行和第四行 （从2开始，每次递增2个单位，到5结束）</span></span><br><span class="line">A(<span class="number">2</span>:<span class="number">2</span>:<span class="number">5</span>,:)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 输出1，4，7，10</span></span><br><span class="line"><span class="number">1</span>:<span class="number">3</span>:<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 输出10，9，8，···，1</span></span><br><span class="line"><span class="number">10</span>:<span class="number">-1</span>:<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 取第二行到最后一行</span></span><br><span class="line">A(<span class="number">2</span>:<span class="keyword">end</span>,:)</span><br><span class="line"></span><br><span class="line"><span class="comment">%取第二行和倒数第二行</span></span><br><span class="line">A(<span class="number">2</span>:<span class="keyword">end</span><span class="number">-1</span>,:)</span><br></pre></td></tr></table></figure><p>(5)取全部元素，按列拼接最终输出列向量</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">A(:)</span><br></pre></td></tr></table></figure><ol start="7"><li>size函数<br>size(A)函数是用来求矩阵A的大小的,它返回一个行向量，第一个元素是矩阵的行数，第二个元素是矩阵的列数。</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">B = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="built_in">size</span>(A)</span><br><span class="line"><span class="built_in">size</span>(B)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 将矩阵A的行数返回到第一个变量r，列数返回至c</span></span><br><span class="line">[r,c] = <span class="built_in">size</span>(A)</span><br><span class="line">r = <span class="built_in">size</span>(A,<span class="number">1</span>)  <span class="comment">%返回行数</span></span><br><span class="line">c = <span class="built_in">size</span>(A,<span class="number">2</span>) <span class="comment">%返回列数</span></span><br></pre></td></tr></table></figure><ol start="8"><li>repmat函数<br>B = repmat(A,m,n):将矩阵A复制m×n块，即把A作为B的元素，B由m×n个A平铺而成。</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">B = <span class="built_in">repmat</span>(A,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">C = <span class="built_in">repmat</span>(A,<span class="number">3</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><ol start="8"><li>find函数<br>它可以用来返回向量或者矩阵中不为0的元素的位置索引。(索引序号从1开始)，以下是一维向量的用法。</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">X = [<span class="number">1</span> <span class="number">0</span> <span class="number">4</span> <span class="number">-3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">8</span> <span class="number">6</span>]</span><br><span class="line">ind = <span class="built_in">find</span>(X)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 返回前2个不为0的元素的位置</span></span><br><span class="line">ind = <span class="built_in">find</span>(X,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>若X是一个矩阵（二维，有行和列）</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">X = [<span class="number">1</span> <span class="number">-3</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">8</span>;<span class="number">4</span> <span class="number">0</span> <span class="number">6</span>]</span><br><span class="line">ind = <span class="built_in">find</span>(X)</span><br></pre></td></tr></table></figure><p>返回结果ind =1 3 4 8 9，这是因为在Matlab在存储矩阵时，是一列一列存储的。例如输入X(4)，结果将返回为-3。假如你需要按照行列的信息输出，操作如下。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% r代表行，c代表列</span></span><br><span class="line">[r,c] = <span class="built_in">find</span>(X)</span><br><span class="line">[r,c] = <span class="built_in">find</span>(X,<span class="number">1</span>)  <span class="comment">%只找第一个非0元素</span></span><br></pre></td></tr></table></figure><ol start="9"><li>判断语句<br>if所在的行不需要冒号，语句的最后一定要以end结尾；中间的语句要注意缩进。</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">s = input(‘请输入考试分数’)</span><br><span class="line"><span class="keyword">if</span> a &gt;= <span class="number">85</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;优秀&#x27;</span>)</span><br><span class="line"><span class="keyword">elseif</span> a &gt;= <span class="number">60</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;合格&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;不及格&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ol start="10"><li><p>zeros&amp;ones函数<br>生成零矩阵和单位矩阵。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">zeros</span>(<span class="number">3</span>) <span class="comment">% 一个3*3的方阵</span></span><br><span class="line"><span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>) <span class="comment">% 3行1列矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ones</span>(<span class="number">5</span>) <span class="comment">% 一个5*5的方阵</span></span><br><span class="line"><span class="built_in">ones</span>(<span class="number">5</span>,<span class="number">2</span>) <span class="comment">% 5行2列矩阵</span></span><br></pre></td></tr></table></figure></li><li><p>abs绝对值函数、max&amp;min函数</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">X=[<span class="number">2</span> <span class="number">1</span> <span class="number">3</span>;<span class="number">-4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"><span class="built_in">abs</span>(X)</span><br><span class="line">Y=[<span class="number">1</span> <span class="number">0</span> <span class="number">-9</span> <span class="number">8</span> <span class="number">-10</span>]</span><br><span class="line"><span class="built_in">max</span>(Y)</span><br><span class="line"><span class="built_in">min</span>(Y)</span><br></pre></td></tr></table></figure></li><li><p>magic函数<br>幻方矩阵，M = magic(n)返回由1到n^2的整数构成并且总行数和总列数相等的n×n矩阵。阶次n必须为大于或等于3的标量。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A=<span class="built_in">magic</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure></li><li><p>sort排序函数</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>]</span><br><span class="line"><span class="built_in">sort</span>(A) <span class="comment">% 若A是向量不管是列还是行向量，默认都是对A进行升序排列，若A是矩阵，默认对A的各列进行升序排列。</span></span><br><span class="line"><span class="built_in">sort</span>(A,<span class="string">&#x27;descend&#x27;</span>) <span class="comment">% 降序排序</span></span><br><span class="line"><span class="built_in">sort</span>(A,dim) <span class="comment">% dim=1时等效sort(A)，dim=2时表示对A中的各行元素升序排列。</span></span><br><span class="line">[sA,index] = <span class="built_in">sort</span>(A,<span class="string">&#x27;descend&#x27;</span>) <span class="comment">% 若欲保留排列前的索引，则可用[sA,index] = sort(A,&#x27;descend&#x27;)，sA是排序好的向量，index是向量sA中对A的索引。</span></span><br><span class="line"><span class="comment">% 排序后</span></span><br><span class="line"><span class="comment">% sA  =  8     3     2     1</span></span><br><span class="line"><span class="comment">% index =  4     3     1     2</span></span><br></pre></td></tr></table></figure></li><li><p>legend函数<br>用来标注图片</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;ro&#x27;</span>,new_x,p1,<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;原始数据&#x27;</span>,<span class="string">&#x27;三次埃尔米特插值数据&#x27;</span>,<span class="string">&#x27;Location&#x27;</span>,<span class="string">&#x27;SouthEast&#x27;</span>); <span class="comment">% 右下方</span></span><br></pre></td></tr></table></figure></li><li><p>subplot函数</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">subplot(<span class="number">4</span>,<span class="number">3</span>,<span class="built_in">i</span><span class="number">-1</span>);<span class="comment">%将所有图依次变现在4*3的一幅大图上</span></span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line"><span class="number">16.</span> <span class="built_in">plot</span>函数</span><br><span class="line">画图</span><br><span class="line">```matlab</span><br><span class="line"><span class="built_in">plot</span>(x1,y1,x2,y2)</span><br></pre></td></tr></table></figure></li></ol><p>线方式： ‐ 实线  :点线  ‐. 虚点线  ‐ ‐ 波折线<br>点方式： . 圆点  +加号  * 星号  x x形  o 小圆<br>颜色： y黄  r红  g绿  b蓝  w白  k黑  m紫  c青</p><ol start="17"><li><p> axis函数</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">axis([<span class="number">0</span> <span class="number">15</span>,-<span class="built_in">inf</span>,<span class="built_in">inf</span>])  <span class="comment">%设置坐标轴的范围，这里设置横坐标轴0-15，纵坐标不变化</span></span><br></pre></td></tr></table></figure></li><li><p>xlabel&amp;ylabel函数</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">xlabel(<span class="string">&#x27;星期&#x27;</span>)<span class="comment">%x轴标题</span></span><br><span class="line">ylabel(ylab&#123;<span class="built_in">i</span>&#125;)<span class="comment">%y轴标题  这里是直接引用元胞数组中的字符串</span></span><br></pre></td></tr></table></figure></li><li><p>生成随机数函数</p></li></ol><p><strong>randi</strong> : 产生均匀分布的随机整数（i = int）<br><strong>and</strong> : 产生0至1之间均匀分布的随机数<br><strong>normrnd</strong> : 产生正态分布的随机数<br><strong>roundn</strong> : —任意位置四舍五入</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%产生一个1至10之间的随机整数矩阵，大小为2x5；</span></span><br><span class="line">s1 = randi(<span class="number">10</span>,<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment">%产生一个-5至5之间的随机整数矩阵，大小为1x10；</span></span><br><span class="line">s2 = randi([<span class="number">-5</span>,<span class="number">5</span>],<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"><span class="comment">%产生一个0至1之间的随机矩阵，大小为1x5；</span></span><br><span class="line">s3 = <span class="built_in">rand</span>(<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment">%产生一个a至b之间的随机矩阵，大小为1x5；  </span></span><br><span class="line"><span class="comment">% a + (b-a) * rand(1,5); 如：a,b = 2,5</span></span><br><span class="line">s4= <span class="number">2</span> + (<span class="number">5</span><span class="number">-2</span>) * <span class="built_in">rand</span>(<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment">%产生一个均值为0，标准差（方差开根号）为2的正态分布的随机矩阵，大小为3x4；</span></span><br><span class="line">s5 = normrnd(<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">skewness(x) <span class="comment">%偏度</span></span><br><span class="line">kurtosis(x) <span class="comment">%峰度</span></span><br><span class="line"><span class="comment">% 0个位 1十位  2百位 -1小数点后一位  </span></span><br><span class="line">a = <span class="number">3.1415</span></span><br><span class="line">roundn(a,<span class="number">-2</span>)    <span class="comment">% ans   =  3.1400</span></span><br><span class="line">roundn(a,<span class="number">2</span>)      <span class="comment">% ans   =  0</span></span><br><span class="line">a =<span class="number">31415</span></span><br><span class="line">roundn(a,<span class="number">2</span>)   <span class="comment">% ans  = 31400</span></span><br><span class="line">roundn(<span class="number">5.5</span>,<span class="number">0</span>)  <span class="comment">%6</span></span><br><span class="line">roundn(<span class="number">5.5</span>,<span class="number">1</span>) <span class="comment">%10</span></span><br></pre></td></tr></table></figure><ol start="20"><li><p>jbtest函数</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 当输出h等于1时，表示拒绝原假设； h等于0则代表不能拒绝原假设。</span></span><br><span class="line"><span class="comment">% alpha就是显著性水平，一般取0.05，此时置信水平为1‐0.05=0.95</span></span><br><span class="line"><span class="comment">% x就是我们要检验的随机变量,x只能是向量</span></span><br><span class="line">[h,p] = jbtest(x,alpha)</span><br></pre></td></tr></table></figure></li><li><p>相关系数计算函数</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%%Pearson相关系数</span></span><br><span class="line">R = corrcoef(Test) </span><br><span class="line"><span class="comment">% 计算各列之间的相关系数以及p值</span></span><br><span class="line">[R,P] = corrcoef(Test)</span><br><span class="line"></span><br><span class="line"><span class="comment">%%spearman相关系数</span></span><br><span class="line"><span class="comment">% XY必须为列向量</span></span><br><span class="line">coeff = corr(X , Y , <span class="string">&#x27;type&#x27;</span> , <span class="string">&#x27;Spearman&#x27;</span>)</span><br><span class="line"><span class="comment">% 等价于：</span></span><br><span class="line">RX = [<span class="number">2</span> <span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span>]</span><br><span class="line">RY = [<span class="number">1</span> <span class="number">4.5</span> <span class="number">3</span> <span class="number">4.5</span> <span class="number">2</span>]</span><br><span class="line">R = corrcoef(RX,RY)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算矩阵各列的斯皮尔曼相关系数</span></span><br><span class="line">R = corr(Test, <span class="string">&#x27;type&#x27;</span> , <span class="string">&#x27;Spearman&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 直接给出相关系数和p值</span></span><br><span class="line">[R,P]=corr(Test, <span class="string">&#x27;type&#x27;</span> , <span class="string">&#x27;Spearman&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ol><h2 id="三-矩阵运算"><a href="#三-矩阵运算" class="headerlink" title="三.矩阵运算"></a>三.矩阵运算</h2><ol><li>MATLAB在矩阵的运算中，“<em>”号和“/”号代表矩阵之间的乘法与除法(A/B = A</em>inv(B))。</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">B = [<span class="number">1</span>,<span class="number">0</span>;<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">A * B</span><br><span class="line"></span><br><span class="line">inv(B) <span class="comment">% B的逆矩阵</span></span><br><span class="line">B * inv(B)</span><br><span class="line">A * inv(B)</span><br><span class="line">A/B</span><br></pre></td></tr></table></figure><ol start="2"><li>两个形状相同的矩阵对应元素之间的乘除法需要使用“.*”和“./”。</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">B = [<span class="number">1</span>,<span class="number">0</span>;<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">A .* B</span><br><span class="line">A ./ B</span><br><span class="line"></span><br><span class="line"><span class="comment">% 每个元素同时和常数相乘或相除操作，两种方法均可以使用</span></span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">A * <span class="number">2</span></span><br><span class="line">A .*<span class="number">2</span></span><br><span class="line">A / <span class="number">2</span></span><br><span class="line">A ./ <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 每个元素同时乘方只能用.^</span></span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="comment">% 每个元素的平方</span></span><br><span class="line">A .^ <span class="number">2</span></span><br><span class="line"><span class="comment">% 矩阵的平方</span></span><br><span class="line">A ^ <span class="number">2</span></span><br><span class="line">A * A</span><br></pre></td></tr></table></figure><ol start="3"><li>矩阵求特征值和特征向量<br>在Matlab中，计算矩阵A的特征值和特征向量的函数是eig(A)。以下是两个常用的用法。</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>;<span class="number">2</span> <span class="number">2</span> <span class="number">1</span>;<span class="number">2</span> <span class="number">0</span> <span class="number">3</span>]</span><br><span class="line"><span class="comment">% (1) E=eig(A) 求矩阵A的全部特征值，构成向量E</span></span><br><span class="line">E = eig(A)</span><br><span class="line"><span class="comment">% (2) [V,D]=eig(A),求矩阵A的全部特征值，构成对角阵D；</span></span><br><span class="line"><span class="comment">% 并求A的特征向量构成V的列向量</span></span><br><span class="line"><span class="comment">% V的每一列都是D中与之相同列的特征值的特征向量）</span></span><br><span class="line">[V,D]=eig(A)</span><br></pre></td></tr></table></figure><ol start="4"><li>矩阵与常数的大小判断运算<br>共有三种运算符：大于&gt; ;小于&lt; ;等于 ==  （一个等号表示赋值；两个等号表示判断）</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">X = [<span class="number">1</span> <span class="number">-3</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">8</span>;<span class="number">4</span> <span class="number">0</span> <span class="number">6</span>]</span><br><span class="line">X &gt; <span class="number">0</span></span><br><span class="line">x == <span class="number">4</span></span><br><span class="line"><span class="comment">% 输出为一个3x3的逻辑矩阵，&gt;0的位置为1，&lt;0的位置为0</span></span><br></pre></td></tr></table></figure><h2 id="四-工具箱"><a href="#四-工具箱" class="headerlink" title="四.工具箱"></a>四.工具箱</h2><ol><li>cftool(Curve Fitting tool)</li></ol><ul><li>Custom Equations：用户自定义的函数类型</li><li>Exponential：指数逼近，有2种类型， a<em>exp(b</em>x) 、 a<em>exp(b</em>x) + c<em>exp(d</em>x)</li><li>Fourier：傅立叶逼近，有7种类型，基础型是 a0 + a1<em>cos(x</em>w) + b1<em>sin(x</em>w)</li><li>Gaussian：高斯逼近，有8种类型，基础型是 a1*exp(-((x-b1)/c1)^2)</li><li>Interpolant：插值逼近，有4种类型，linear、nearest neighbor、cubic spline、shape-preserving</li><li>Polynomial：多形式逼近，有9种类型，linear ~、quadratic ~、cubic ~、4-9th degree ~</li><li>Power：幂逼近，有2种类型，a<em>x^b 、a</em>x^b + c</li><li>Rational：有理数逼近，分子、分母共有的类型是linear ~、quadratic ~、cubic ~、4-5th degree ~；此外，分子还包括constant型</li><li>Smoothing Spline：平滑逼近（</li><li>Sum of Sin Functions：正弦曲线逼近，有8种类型，基础型是 a1<em>sin(b1</em>x + c1)</li><li>Weibull：只有一种，a<em>b</em>x^(b-1)<em>exp(-a</em>x^b)</li></ul><p>输出：<br>SSE(和方差、误差平方和)：The sum of squares due to error<br>MSE(均方差、方差)：Mean squared error<br>RMSE(均方根、标准差)：Root mean squared error<br>R-square(确定系数)：Coefficient of determination “确定系数”是通过数据的变化来表征一个拟合的好坏。正常取值范围为[0 1]，越接近1，表明方程的变量对y的解释能力越强，这个模型对数据拟合的也较好。<br>Adjusted R-square：Degree-of-freedom adjusted coefficient of determination</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 数学建模 </category>
          
          <category> Matlab基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数学建模 </tag>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML学习笔记</title>
      <link href="/2022/08/07/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/08/07/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML学习笔记-持续更新中···"><a href="#HTML学习笔记-持续更新中···" class="headerlink" title="HTML学习笔记(持续更新中···)"></a>HTML学习笔记(持续更新中···)</h1><pre><code>HTML(Hypertext Makeup Language),超文本标记语言，是一种用于创建网页的标准标记语言。</code></pre><ul><li>标记语言、标记标签</li><li>HTML使用标记标签来描述网页</li><li>HTML文档包含了HTML标签及文本内容</li><li>HTML文档也叫做web页面</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Jupiter&#x27;s note<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>!DOCTYPE html<br>是一条标记语言，具体含义为 HTML5 标准网页声明，全称为 Document Type HyperText Mark-up Language。该声明位于文档中最前面的位置，处于<html>标签之前，支持 HTML5 标准的主流浏览器都认识这个声明，不区分大小写。</li><li>html<br>是 HTML 页面的根元素</li><li>head<br>元素包含了文档的元（meta）数据，如   <meta charset="utf-8">定义网页编码格式为 utf-8。</li><li>title<br>元素描述了文档的标题</li><li>body<br>元素包含了可见的页面内容</li><li>h1<br>元素定义一个大标题</li><li>p<br>元素定义一个段落</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="文档命名"><a href="#文档命名" class="headerlink" title="文档命名"></a>文档命名</h3><ul><li>.html 超文本标记(Hypertext Markup)</li><li>.htm 超文本标记语言(Hypertext Markup Language)</li></ul><h3 id="HTML标签"><a href="#HTML标签" class="headerlink" title="HTML标签"></a>HTML标签</h3><p>HTML标记标签通常被称为HTML标签(HTML tag)。</p><ul><li>HTML 标签是由尖括号包围的关键词，比如 <html></li><li>成对出现，标签对中的第一个标签是开始标签，第二个标签是结束标签，也被称为开放标签和闭合标签。</li></ul><h3 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h3><p>与标签概念相同，但一个 HTML 元素包含了开始标签与结束标签。</p><h3 id="Web浏览器"><a href="#Web浏览器" class="headerlink" title="Web浏览器"></a>Web浏览器</h3><p>用于读取HTML文件，并将其作为网页显示。浏览器并不是直接显示的HTML标签，但可以使用标签来决定如何展现HTML页面的内容给用户。</p><h2 id="HTML基础"><a href="#HTML基础" class="headerlink" title="HTML基础"></a>HTML基础</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>通过h1 - h6 标签来定义。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是标题1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是标题2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是标题3<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>通过标签 p 来定义。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是段落1。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是段落2。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>通过标签 a 来定义，在href属性中指定链接的地址。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://jupitercy.github.io/&quot;</span>&gt;</span>这是一个链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h3><p>通过标签 img 来定义，以属性形式规定图像名称和尺寸。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/images/logo.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;258&quot;</span> <span class="attr">height</span>=<span class="string">&quot;39&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 前端 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Next插入图片</title>
      <link href="/2022/08/04/Hexo-Next%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
      <url>/2022/08/04/Hexo-Next%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo图片无法加载问题"><a href="#Hexo图片无法加载问题" class="headerlink" title="Hexo图片无法加载问题"></a>Hexo图片无法加载问题</h1><pre><code>在第一篇博客中，想要插入一张图片。一番折腾后，终于在本地可以成功显示图片，但在部署到GitHub上之后还是无法加载。在网上搜了很多方法，最终也终于解决了问题。</code></pre><h2 id="图片插入步骤"><a href="#图片插入步骤" class="headerlink" title="图片插入步骤"></a>图片插入步骤</h2><h3 id="Step1"><a href="#Step1" class="headerlink" title="Step1"></a>Step1</h3><p>打开站点配置_config.yml文件，修改以下内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>开启资源文件夹功能，表示在新建博客’hexo new “title”’时，会在根目录下创建一个同名文件夹，我们把要插入的图片存放到这个文件夹里就好啦。</p><img src="/2022/08/04/Hexo-Next%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class="" title="根目录下文件示意图"><img src="/2022/08/04/Hexo-Next%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/%E5%AD%98%E5%9B%BE%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class="" title="将图片存放在对应文件夹里"><h3 id="Step2"><a href="#Step2" class="headerlink" title="Step2"></a>Step2</h3><p>安装插件<strong>hexo-asset-image</strong>，作用是图片路径转换。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><h3 id="Step3"><a href="#Step3" class="headerlink" title="Step3"></a>Step3</h3><p><strong>敲黑板！！！接下来是重点！！</strong></p><p>安装完成后，我们需要修改插件的配置信息。打开/node_modules/hexo-asset-image/index.js，将文件内容替换为以下所示代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getPosition</span>(<span class="params">str, m, i</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">split</span>(m, i).<span class="title function_">join</span>(m).<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="title class_">String</span>(hexo.<span class="property">version</span>).<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.<span class="property">config</span>;</span><br><span class="line">  <span class="keyword">if</span>(config.<span class="property">post_asset_folder</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> link = data.<span class="property">permalink</span>;</span><br><span class="line"><span class="keyword">if</span>(version.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; <span class="title class_">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">   <span class="keyword">var</span> beginPos = <span class="title function_">getPosition</span>(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">var</span> beginPos = <span class="title function_">getPosition</span>(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line"><span class="keyword">var</span> endPos = link.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.<span class="title function_">substring</span>(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.<span class="property">length</span>; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.<span class="title function_">load</span>(data[key], &#123;</span><br><span class="line">        <span class="attr">ignoreWhitespace</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">xmlMode</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">lowerCaseTags</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">decodeEntities</span>: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).<span class="title function_">each</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">if</span> ($(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line"><span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line"><span class="keyword">var</span> src = $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>).<span class="title function_">replace</span>(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.<span class="title function_">test</span>(src) &amp;&amp;</span><br><span class="line">   !<span class="regexp">/^\s*\//</span>.<span class="title function_">test</span>(src)) &#123;</span><br><span class="line">  <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">  <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">  <span class="keyword">var</span> linkArray = link.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">elem</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> srcArray = src.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">elem</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span>(srcArray.<span class="property">length</span> &gt; <span class="number">1</span>)</span><br><span class="line">srcArray.<span class="title function_">shift</span>();</span><br><span class="line">  src = srcArray.<span class="title function_">join</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">  $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>, config.<span class="property">root</span> + link + src);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.<span class="property">root</span> + link + src);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>($(<span class="variable language_">this</span>));</span><br><span class="line">&#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.<span class="title function_">html</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Step4"><a href="#Step4" class="headerlink" title="Step4"></a>Step4</h3><p>准备工作做好了，接下来在对应的md文件中按照以下规则插入图片。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img 图名.png 图片描述 %&#125;</span><br></pre></td></tr></table></figure><h3 id="Step5"><a href="#Step5" class="headerlink" title="Step5"></a>Step5</h3><p>最后一步，还是那套clean+g+d的流程，就可以显示了。</p><p><em>Tips:</em><br><em>如果在Github上部署之后，发现页面没有发生变化，试试‘shift+F5’，说不定就能解决问题。记得一定要等一等，页面可能有延迟，加载比较慢</em></p><h2 id="一个小坑"><a href="#一个小坑" class="headerlink" title="一个小坑"></a>一个小坑</h2><p>在网上查的时候还发现一种方法，我一开始也是使用的这种markdown语法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">![图片描述](/图名.<span class="property">png</span>)</span><br></pre></td></tr></table></figure><p>不过，看了很多相关教程，也没找到有效的能使图片在页面上显示的方法。最终发现似乎是由于版本问题（Hexo 2 v Hexo 3）导致的，感兴趣的uu们可以进一步探究。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Hexo </category>
          
          <category> 常见问题 </category>
          
          <category> Next主题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
            <tag> 常见问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/02/hello-world/"/>
      <url>/2022/08/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
