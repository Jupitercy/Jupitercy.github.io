<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OSmooc题目整理</title>
      <link href="/2022/10/13/OSmooc%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/"/>
      <url>/2022/10/13/OSmooc%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章单元测试"><a href="#第一章单元测试" class="headerlink" title="第一章单元测试"></a>第一章单元测试</h1><p>1.操作系统是对（ A）进行管理的软件。<br>A.计算机资源<br>B.软件<br>C.硬件<br>D.应用程序</p><p>2.操作系统是一种（ C）。<br>A.应用软件<br>B.通用软件<br>C.系统软件<br>D.软件</p><p>3下列选项中，不属于多道程序设计的基本特征是（ D）<br>A.间断性<br>B.多道性<br>C.无序性<br>D.顺序性</p><p>4.提高CPU利用率的关键技术是（C ）<br>A.脱机技术<br>B.交换技术<br>C.多道程序设计技术<br>D.虚拟技术</p><p>5分时系统追求的目标是（ A）<br>A.快速响应用户<br>B.充分利用I/O设备<br>C.充分利用内存<br>D.提高系统吞吐率<br>、</p><h1 id="第二章单元测试"><a href="#第二章单元测试" class="headerlink" title="第二章单元测试"></a>第二章单元测试</h1><p>1.处理器执行的指令被分为两类，其中有一类称为特权指令，它只允许（C ）使用<br>A.联机用户<br>B.操作员<br>C.操作系统<br>D.目标程序</p><p>2.当CPU执行操作系统代码时，处理器处于（B）<br>A.用户态<br>B.核心态<br>C.就绪态<br>D.自由态</p><p>3.操作系统提供给编程人员的接口是（ C）<br>A.高级语言<br>B.库函数<br>C.系统调用<br>D.子程序</p><p>4.在中断发生后，进入中断处理的程序属于（ C）<br>A.可能是应用程序，也可能是操作系统程序<br>B.既不是应用程序，也不是操作系统程序<br>C.操作系统程序<br>D.用户程序</p><p>5.下列必须在核心态下执行的指令是（B ）<br>A.从内存中取数<br>B.I/O操作<br>C.将运算结果装入内存<br>D.算术运算</p><h1 id="第三章单元测试"><a href="#第三章单元测试" class="headerlink" title="第三章单元测试"></a>第三章单元测试</h1><p>1.一个进程是（C）。<br>A.由协处理器执行的一个程序<br>B.一个独立的程序+数据集<br>C.PCB结构与程序和数据的组合<br>D.一个独立的程序</p><p>2.进程与程序的根本区别是（C）。<br>A.是不是占有处理器<br>B.是不是被调入到内存<br>C.静态和动态的区别<br>D.是不是具有就绪、运行和等待三种状态</p><p>3.操作系统是根据（C）来对并发执行的进程进行控制和管理的。<br>A.多道程序设计<br>B.进程的基本状态<br>C.进程控制块<br>D.进程的优先权</p><p>4下列几种关于进程的叙述，（D）是最不符合操作系统对进程的理解。<br>A.进程是程序在一个数据集合上的运行过程<br>B.进程可以由程序、数据和PCB描述<br>C.进程是系统进行资源分配和调度的一个独立单元<br>D.进程是在多程序环境中的完整的程序</p><p>5.同一程序经过多次创建，运行在不同的数据集上，形成了（C）的进程。<br>A.互斥<br>B.相同<br>C.不同<br>D.同步</p><p>6.用信箱实现进程间互通消息的通信机制要有两个通信原语，它们是（A）。<br>A.发送原语和接收原语<br>B.就绪原语和执行原语<br>C.发送原语和执行原语<br>D.就绪原语和接收原语</p><p>7.当（D）时，进程从执行状态转变为就绪状态。<br>A.进程被调度程序选中<br>B.等待某一事件<br>C.等待的事件发生<br>D.时间片到</p><p>8.进程创建后，所有创建完成的PCB被链接成一个序列，这个序列称为（C）。<br>A.作业队列<br>B.阻塞队列<br>C.就绪队列<br>D.运行队列</p><p>9.长（作业）调度程序控制（D ）。<br>A.进程执行的时间<br>B.等待队列中进程的个数<br>C.就绪进程的个数<br>D.多道程序的道</p><p>10.在单处理器系统中，如果同时存在10个进程，则处于就绪队列中的进程最多有（A）个。<br>A.9<br>B.1<br>C.8<br>D.10</p><p>11判断(2分)<br>一个进程的状态变化一定会引起另一个进程的状态变化。<br>×错</p><p>12判断(2分)<br>一个进程等待的I/O操作完成后，进程状态将会从阻塞变为就绪。<br>对√</p><p>13判断(2分)<br>执行fork系统调用时，子进程会复制父进程的地址空间。<br>对√</p><p>14判断(2分)<br>与其他进程共享数据的进程是协作进程。<br>对√</p><p>15判断(2分)<br>短调度是指从作业队列中选择作业并装入内存。<br>错×<br>.</p><h1 id="第四章单元测试"><a href="#第四章单元测试" class="headerlink" title="第四章单元测试"></a>第四章单元测试</h1><p>1.若某一进程拥有100个线程，这些线程都属于用户级线程，则每一个线程在系统调度时间上占用的时间片是（想知道答案，请留言、点赞、并私聊 ）。</p><p>A.1<br>B.0<br>C.100<br>D.1/100</p><p>2.在多对一的线程模型中，当一个多线程进程的某个线程被阻塞后（C）。<br>A.该阻塞线程将永远不可能在执行<br>B.该阻塞线程将被撤销<br>C.整个进程都将被阻塞<br>D.该进程的其他线程仍可继续运行</p><p>3.下面的叙述中，正确的是（D）。<br>A.同一进程或不同进程内的线程都只能串行执行<br>B.同一进程内的线程可并发执行，不同进程的线程只能串行执行<br>C.同一进程内的线程只能串行执行，不同进程的线程可并发执行<br>D.同一进程或不同进程内的线程都可以并发执行</p><p>4.下面说法正确的是（B）。<br>A.不论是系统支持的线程还是用户级线程，其切换都需要内核的支持<br>B.不管系统中是否有线程，进程都是拥有资源的独立单位<br>C.在引入线程的系统中，进程仍是资源调度和分派的基本单位<br>D.线程是资源分配的单位，进程是调度和分派的单位</p><p>5.引入线程的主要目的是（B ）。<br>A.执行更多任务<br>B.提高并发程度同时降低开销<br>C.加快运算速度<br>D.实现资源共享</p><p>6.线程也具有就绪、阻塞和运行三种基本状态。<br>对√</p><p>7.CPU调度时，时间片是分给用户线程的。<br>错×</p><p>8.多对一模型的缺点是不能实现真正的并发。<br>对√</p><p>9.用户线程是在用户空间管理的，内核也能感知。<br>错×</p><p>10.同一个进程内的多个线程之间共享进程的资源。<br>对√</p><h1 id="第五章单元测试"><a href="#第五章单元测试" class="headerlink" title="第五章单元测试"></a>第五章单元测试</h1><p>1.在单处理器的多进程系统中，进程什么时候占用处理器以及决定占用时间的长短是由（B）决定的。<br>A.进程相应的代码长度<br>B.进程特点和进程调度策略<br>C.进程总共需要运行的时间<br>D.进程完成什么功能</p><p>2.（C ）有利于CPU繁忙型的作业，而不利于I/O繁忙型的作业。<br>A.时间片轮转调度算法<br>B.短作业（进程）优先算法<br>C.先来先服务调度算法<br>D.优先权调度算法</p><p>3.时间片轮转调度算法是为了（D）。<br>A.使系统变得高效<br>B.需要CPU时间最少的进程最先做<br>C.优先级较高的进程得到及时响应<br>D.多个终端能够得到系统及时响应</p><p>4.（A）优先级是在创建进程时确定的，确定之后在整个运行期间不再改变。<br>A.静态<br>B.动态<br>C.先来先服务<br>D.短作业</p><p>5.采用时间片轮转调度算法分配CPU时，当处于运行状态的进程用完一个时间片后，他的状态是（C ）状态。<br>A.运行<br>B.消亡<br>C.就绪<br>D.阻塞</p><p>6.下列调度算法中，（B）调度算法是绝对可抢占的。<br>A.优先级<br>B.时间片轮转<br>C.短进程优先<br>D.先来先服务</p><p>7.下列选项中，降低进程优先级的合理时机是（D）。<br>A.进程刚完成I/O操作，进入就绪队列<br>B.进程从就绪状态转为运行状态<br>C.进程长期处于就绪队列<br>D.进程时间片用完</p><p>8.设有4个作业同时到达，每个作业的执行时间均为2h，它们在一台处理器上技单道</p><p>式运行，则平均周转时间为（D）。<br>A.8h<br>B.1h<br>C.2.5h<br>D.5h</p><p>9.假设系统中所有的进程都是同时到达，则使进程平均等待时间最短的是（ C）调度算法。<br>A.时间片轮转<br>B.先来先服务<br>C.短作业优先<br>D.优先级</p><p>10.下面关于选择进程调度算法的准则中不正确的是（B ）。<br>A.尽快响应交互式用户的请求<br>B.适当增加进程在就绪队列的等待时间<br>C.尽量提高CPU利用率<br>D.尽可能提高系统的吞吐量</p><h1 id="第六章单元测试"><a href="#第六章单元测试" class="headerlink" title="第六章单元测试"></a>第六章单元测试</h1><p>1单选(2分)<br>下列对临界区的论述中，正确的是（ A）。<br>A.临界区是指进程中用于访问共享资源的那段代码<br>B.临界区是指进程中用于实现进程互斥的那段代码<br>C.临界区是指进程中用于实现进程同步的那段代码<br>D.临界区是指进程中用于实现进程通信的那段代码</p><p>2单选(2分)<br>若一个信号量的初值为3，经过多次PV操作以后当前值为－1，此表示等待进入临界区的进程数是（ C ）。<br>A.3<br>B.4<br>C.1<br>D.2</p><p>3单选(2分)<br>设与某资源关联的信号量（K）初值为3，当前值为1。若M表示该资源的可用个数，N表示等待该资源的进程数，则M、N分别是（B）。<br>A.0、1<br>B.1、0<br>C.2、0<br>D.1、2</p><p>4单选(2分)<br>P操作可能导致（D）。<br>A.进程结束<br>B.进程就绪<br>C.新进程创建<br>D.进程阻塞</p><p>5单选(2分)<br>用V操作唤醒一个等待进程时，被唤醒进程的变为（D）状态。<br>A.运行<br>B.等待<br>C.完成<br>D.就绪</p><p>6单选(2分)<br>在用信号量机制实现互斥时，互斥信号量的初值为（A）。<br>A.1<br>B.2<br>C.3<br>D.0</p><p>7单选(2分)<br>有三个进程共享同一程序段，而每次只允许两个进程进入该程序段，若用PV操作同步机制，则信号量S的取值范围是（A）。<br>A.2，1，0，-1<br>B.1，0，-1，-2<br>C.3，2，1，0<br>D.2，1，0，-1，-2</p><p>8单选(2分)<br>对于两个并发进程，设互斥信号量为 mutex（初值为1），若 mutex＝0，则（B）。<br>A.表示有一个进程进入临界区，另一个进程等待进入<br>B.表示有一个进程进入临界区<br>C.表示有两个进程进入临界区<br>D.表示没有进程进入临界区</p><p>9单选(2分)<br>在操作系统中，要对并发进程进行同步的原因是（ C ）。<br>A.进程具有动态性<br>B.进程必须在有限的时间内完成<br>C.并发进程是异步的<br>D.进程具有结构性</p><p>10单选(2分)<br>在操作系统中，要对并发进程进行同步的原因是（ B ）。<br>A.进程具有动态性<br>B.并发进程是异步的<br>C.进程具有结构性<br>D.进程必须在有限的时间内完成</p><p>11判断(2分)<br>临界区就是临界资源所在的区域。<br>错×</p><p>12判断(2分)<br>信号量是一个整型变量，可以直接对其进行加1和减1的操作。<br>错×</p><p>13判断(2分)<br>V操作表示申请一个资源。<br>错×</p><p>14判断(2分)<br>一个正在访问临界资源的进程因为申请I/O操作而阻塞时，它允许其他进程进入其临界区。<br>错×</p><p>15判断(2分)<br>PV操作是原子操作。<br>对√</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Numpy学习笔记</title>
      <link href="/2022/10/09/Numpy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/10/09/Numpy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>与大多数语言一样，Python有许多基本类型，包括整数，浮点数，布尔值和字符串。这些数据类型的行为方式与其他编程语言相似。</p><h3 id="Numbers-数字类型"><a href="#Numbers-数字类型" class="headerlink" title="Numbers(数字类型)"></a>Numbers(数字类型)</h3><p>代表的是整数和浮点数，它原理与其他语言相同：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=<span class="number">3</span> </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(x)) <span class="comment">#&lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(x) <span class="comment">#3</span></span><br><span class="line"><span class="built_in">print</span>(x+<span class="number">1</span>) <span class="comment">#4</span></span><br><span class="line"><span class="built_in">print</span>(x-<span class="number">1</span>) <span class="comment">#2</span></span><br><span class="line"><span class="built_in">print</span>(x*<span class="number">2</span>) <span class="comment">#6</span></span><br><span class="line"><span class="built_in">print</span>(x**<span class="number">2</span>) <span class="comment">#9</span></span><br><span class="line">x+=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(x) <span class="comment">#4</span></span><br><span class="line">x*=<span class="number">2</span> </span><br><span class="line"><span class="built_in">print</span>(x) <span class="comment">#8</span></span><br><span class="line">y=<span class="number">2.5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(y)) <span class="comment">#&lt;class &#x27;float&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(y,y+<span class="number">1</span>,y*<span class="number">2</span>,y**<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="Booleans-布尔类型"><a href="#Booleans-布尔类型" class="headerlink" title="Booleans(布尔类型)"></a>Booleans(布尔类型)</h3><p>Python实现了所有常用的布尔逻辑运算符，但它使用的是英文单词而不是符号 (&amp;&amp;, ||, etc.)：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = <span class="literal">True</span></span><br><span class="line">f = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t))  <span class="comment">#&lt;class &#x27;bool&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(t <span class="keyword">and</span> f) <span class="comment">#False</span></span><br><span class="line"><span class="built_in">print</span>(t <span class="keyword">or</span> f) <span class="comment">#True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> t) <span class="comment">#False</span></span><br><span class="line"><span class="built_in">print</span>(t!=f) <span class="comment">#True</span></span><br></pre></td></tr></table></figure><h3 id="Strings-字符串类型"><a href="#Strings-字符串类型" class="headerlink" title="Strings(字符串类型)"></a>Strings(字符串类型)</h3><p>Python对字符串有很好的支持：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hello = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">world = <span class="string">&quot;world&quot;</span> <span class="comment"># 双引或单引号都可以</span></span><br><span class="line"><span class="built_in">print</span>(hello) </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(hello)) <span class="comment"># 长度5</span></span><br><span class="line">hw = hello + <span class="string">&#x27; &#x27;</span> +world <span class="comment">#字符串连接</span></span><br><span class="line"><span class="built_in">print</span>(hw)</span><br><span class="line">hw12 = <span class="string">&#x27;%s %s %d&#x27;</span> % (hello,world,<span class="number">12</span>)</span><br><span class="line"><span class="built_in">print</span>(hw12)</span><br></pre></td></tr></table></figure><p>还有很多其他方法:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=<span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.capitalize()) <span class="comment">#Hello 首字母大写</span></span><br><span class="line"><span class="built_in">print</span>(s.upper()) <span class="comment">#变大写</span></span><br><span class="line"><span class="built_in">print</span>(s.rjust(<span class="number">7</span>)) <span class="comment">#左填充空格</span></span><br><span class="line"><span class="built_in">print</span>(s.center(<span class="number">7</span>)) <span class="comment">#填充使得字符串在中心</span></span><br><span class="line"><span class="built_in">print</span>(s.replace(<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;(ell)&#x27;</span>)) <span class="comment">#替换l为ell</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;  world&#x27;</span>.strip()) <span class="comment">#移除字符串头尾指定的字符</span></span><br><span class="line">                        <span class="comment">#（默认为空格或换行符）或字符序列</span></span><br></pre></td></tr></table></figure><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>Python包含几种内置的容器类型：列表、字典、集合和元组。</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表其实就是Python中的数组，但是它可以动态的调整大小并且可以包含不同类型的元素。</p><ul><li>第一个索引是0，第二个索引是1，依此类推。</li><li>Python有6个序列的内置类型，但最常见的是列表和元组。</li><li>序列都可以进行的操作包括索引，切片，加，乘，检查成员。</li><li>列表的数据项<strong>不需要具有相同的类型</strong>。</li></ul><p>创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1=[<span class="string">&#x27;ph&#x27;</span>,<span class="string">&#x27;stu&#x27;</span>,<span class="number">1988</span>,<span class="number">2022</span>]</span><br><span class="line">list2=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">list3=[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>]</span><br></pre></td></tr></table></figure><h3 id="访问列表中的值"><a href="#访问列表中的值" class="headerlink" title="访问列表中的值"></a>访问列表中的值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1=[<span class="string">&#x27;ab&#x27;</span>,<span class="string">&#x27;cd&#x27;</span>,<span class="number">123</span>,<span class="number">456</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;list1[0]:&quot;</span>,list1[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(list1[<span class="number">1</span>:<span class="number">5</span>])</span><br></pre></td></tr></table></figure><h3 id="更新列表"><a href="#更新列表" class="headerlink" title="更新列表"></a>更新列表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>=[]</span><br><span class="line"><span class="built_in">list</span>.append(<span class="string">&#x27;stu&#x27;</span>)</span><br><span class="line"><span class="built_in">list</span>.append(<span class="string">&#x27;net&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="comment"># [&#x27;stu&#x27;, &#x27;net&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="删除列表元素"><a href="#删除列表元素" class="headerlink" title="删除列表元素"></a>删除列表元素</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1=[<span class="string">&#x27;ab&#x27;</span>,<span class="string">&#x27;cd&#x27;</span>,<span class="number">123</span>,<span class="number">456</span>]</span><br><span class="line"><span class="built_in">print</span>(list1)</span><br><span class="line"><span class="keyword">del</span> list1[<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(list1)</span><br><span class="line"><span class="comment">#[&#x27;ab&#x27;, &#x27;cd&#x27;, 123, 456]</span></span><br><span class="line"><span class="comment">#[&#x27;ab&#x27;, &#x27;cd&#x27;, 456]</span></span><br></pre></td></tr></table></figure><h3 id="脚本操作符"><a href="#脚本操作符" class="headerlink" title="脚本操作符"></a>脚本操作符</h3><p>列表对+和* 的操作符与字符串相似。+号用于组合列表* 号用于重复列表。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">#3 #长度</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]+[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>] <span class="comment">#[1,2,3,4,5,6] #组合</span></span><br><span class="line">[<span class="string">&#x27;Hi&#x27;</span>]*<span class="number">4</span> <span class="comment">#[&#x27;Hi&#x27;,&#x27;Hi&#x27;,&#x27;Hi&#x27;,&#x27;Hi&#x27;] #重复</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">#True #元素是否位于列表中</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]:  <span class="comment">#1 2 3 #迭代</span></span><br><span class="line">    <span class="built_in">print</span>(x)   </span><br></pre></td></tr></table></figure><h3 id="列表截取"><a href="#列表截取" class="headerlink" title="列表截取"></a>列表截取</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l=[<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;three&#x27;</span>,<span class="string">&#x27;four&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(l[<span class="number">2</span>]) <span class="comment">#three</span></span><br><span class="line"><span class="built_in">print</span>(l[-<span class="number">1</span>]) <span class="comment">#four</span></span><br><span class="line"><span class="built_in">print</span>(l[<span class="number">1</span>:]) <span class="comment">#[&#x27;two&#x27;, &#x27;three&#x27;, &#x27;four&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="列表函数-amp-方法"><a href="#列表函数-amp-方法" class="headerlink" title="列表函数&amp;方法"></a>列表函数&amp;方法</h3><ol><li>**cmp(list1, list2)**【比较两个列表的元素】</li><li>**len(list)**【列表元素个数】</li><li>**max(list)**【返回列表元素最大值】</li><li>**min(list)**【返回列表元素最小值】</li><li>**list(swq)**【将元组转换为列表】</li><li>**list.append(obj)**【在列表末尾添加新的对象】</li><li>**list.count(obj)**【统计某个元素在列表中出现的次数】</li><li>**list.extend(seq)**【在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）】</li><li>**list.index(obj)**【从列表中找出某个值第一个匹配项的索引位置】</li><li>**list.insert(index, obj)**【将对象插入列表】</li><li>**list.pop([index=-1])**【移除列表中的一个元素（默认最后一个元素），并且返回该元素的值】</li><li>**list.remove(obj)**【移除列表中某个值的第一个匹配项】</li><li>**list.reverse()**【反向列表中元素】</li><li>**list.sort(cmp=None, key=None, reverse=False)**【对原列表进行排序】</li></ol><p>以下是常用操作的集合。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xs = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(xs,xs[<span class="number">2</span>]) <span class="comment">#[3, 1, 2] 2</span></span><br><span class="line"><span class="built_in">print</span>(xs[-<span class="number">1</span>]) <span class="comment">#2</span></span><br><span class="line"><span class="built_in">print</span>(xs[-<span class="number">2</span>]) <span class="comment">#1</span></span><br><span class="line">xs[<span class="number">2</span>]=<span class="string">&#x27;foo&#x27;</span> <span class="comment">#列表中可以放不同类型的元素</span></span><br><span class="line"><span class="built_in">print</span>(xs) <span class="comment">#[3, 1, &#x27;foo&#x27;]</span></span><br><span class="line">xs.append(<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(xs) <span class="comment">#[3, 1, &#x27;foo&#x27;, &#x27;bar&#x27;]</span></span><br><span class="line">x = xs.pop()</span><br><span class="line"><span class="built_in">print</span>(x) <span class="comment">#bar</span></span><br><span class="line"><span class="built_in">print</span>(xs)  <span class="comment">#[3, 1, &#x27;foo&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(x,xs) <span class="comment"># bar [3, 1, &#x27;foo&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="切片-Slicing"><a href="#切片-Slicing" class="headerlink" title="切片(Slicing)"></a>切片(Slicing)</h4><p>除了一次访问一个列表元素之外，Python还提供了访问子列表的简明语法， 这被称为切片。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums=<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>)) <span class="comment">#创建int型list，从0开始的五个</span></span><br><span class="line"><span class="built_in">print</span>(nums) <span class="comment">#输出全部内容</span></span><br><span class="line"><span class="built_in">print</span>(nums[<span class="number">2</span>:<span class="number">4</span>]) <span class="comment">##输出第二个到第四个元素之前的内容</span></span><br><span class="line"><span class="built_in">print</span>(nums[<span class="number">2</span>:]) <span class="comment">#输出第二个到结尾的元素</span></span><br><span class="line"><span class="built_in">print</span>(nums[:<span class="number">2</span>]) <span class="comment">#输出第二个元素之前的内容</span></span><br><span class="line"><span class="built_in">print</span>(nums[:]) <span class="comment">#输出全部</span></span><br><span class="line"><span class="built_in">print</span>(nums[:-<span class="number">1</span>]) <span class="comment">#除了最后一个其他都输出</span></span><br><span class="line">nums[<span class="number">2</span>:<span class="number">4</span>]=[<span class="number">8</span>,<span class="number">9</span>] <span class="comment">#把第二个到第四个之前，即第2，3换成元素8，9</span></span><br><span class="line"><span class="built_in">print</span>(nums)</span><br></pre></td></tr></table></figure><p>(循环)Loops: 可以循环遍历列表的元素，如下所示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">animals=[<span class="string">&#x27;cat&#x27;</span>,<span class="string">&#x27;dog&#x27;</span>,<span class="string">&#x27;monkey&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> animals:</span><br><span class="line">    <span class="built_in">print</span>(animal)</span><br><span class="line"><span class="comment">#cat</span></span><br><span class="line"><span class="comment">#dog</span></span><br><span class="line"><span class="comment">#monkey</span></span><br></pre></td></tr></table></figure><p>如果要访问循环体内每个元素的索引，请使用内置的 enumerate 函数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">animals=[<span class="string">&#x27;cat&#x27;</span>,<span class="string">&#x27;dog&#x27;</span>,<span class="string">&#x27;monkey&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> idx,animal <span class="keyword">in</span> <span class="built_in">enumerate</span>(animals):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;#%d: %s&#x27;</span> % (idx+<span class="number">1</span>,animal))</span><br></pre></td></tr></table></figure><p>列表推导式(List comprehensions): 编程时，我们经常想要将一种数据转换为另一种数据。 举个简单的例子，思考以下计算平方数的代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">squares=[]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">    squares.append(x**<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(squares)</span><br><span class="line"></span><br><span class="line">nums2=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">squares=[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> nums2]</span><br><span class="line"><span class="built_in">print</span>(squares)</span><br><span class="line"></span><br><span class="line">nums3=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">even_squares=[x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> nums3 <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(even_squares)</span><br></pre></td></tr></table></figure><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>Python 的元组与列表类似</p><ul><li>不同之处在于元组的元素不能修改。</li><li>元组使用小括号，列表使用方括号。</li><li>元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。</li></ul><p>如下所示。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1=(<span class="string">&#x27;physics&#x27;</span>,<span class="string">&#x27;chemistry&#x27;</span>,<span class="number">1988</span>,<span class="number">2022</span>)</span><br><span class="line">tup2=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">tup3=<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span></span><br></pre></td></tr></table></figure><p>创建空元组</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1=()</span><br></pre></td></tr></table></figure><p>元组只包含一个元素时，需要在元素后面加逗号。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1=(<span class="number">50</span>,)</span><br></pre></td></tr></table></figure><p>元组与字符串类似，下标索引从0开始，可以进行截取，组合等。</p><h4 id="访问元组"><a href="#访问元组" class="headerlink" title="访问元组"></a>访问元组</h4><p>元组可以使用下标索引来访问元组中的值，如下实例。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1=(<span class="string">&#x27;physics&#x27;</span>,<span class="string">&#x27;chemistry&#x27;</span>,<span class="number">1988</span>,<span class="number">2022</span>)</span><br><span class="line">tup2=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(tup1[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(tup2(<span class="number">1</span>:<span class="number">4</span>))</span><br></pre></td></tr></table></figure><h4 id="修改元组"><a href="#修改元组" class="headerlink" title="修改元组"></a>修改元组</h4><p>元组中的元素值是不允许修改的，但我们可以对元组进行连接组合，如下实例。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1=(<span class="string">&#x27;physics&#x27;</span>,<span class="string">&#x27;chemistry&#x27;</span>,<span class="number">1988</span>,<span class="number">2022</span>)</span><br><span class="line">tup2=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tup1[0]=100 非法操作</span></span><br><span class="line">tup3=tup1+tup2</span><br><span class="line"><span class="built_in">print</span>(tup3)</span><br><span class="line"><span class="comment">#(&#x27;physics&#x27;, &#x27;chemistry&#x27;, 1988, 2022, 1, 2, 3, 4, 5)</span></span><br></pre></td></tr></table></figure><p>元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1=(<span class="string">&#x27;physics&#x27;</span>,<span class="string">&#x27;chemistry&#x27;</span>,<span class="number">1988</span>,<span class="number">2022</span>)</span><br><span class="line"><span class="keyword">del</span> tup1</span><br><span class="line"><span class="built_in">print</span>(tup1) <span class="comment">#删除后，输出变量会有异常信息</span></span><br></pre></td></tr></table></figure><h4 id="元组运算符"><a href="#元组运算符" class="headerlink" title="元组运算符"></a>元组运算符</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)))<span class="comment">#3计算元素个数</span></span><br><span class="line"><span class="built_in">print</span>((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) + (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>))<span class="comment">#(1, 2, 3, 4, 5, 6)连接</span></span><br><span class="line"><span class="built_in">print</span>((<span class="string">&#x27;Hi!&#x27;</span>,) * <span class="number">4</span>)<span class="comment">#(&#x27;Hi!&#x27;, &#x27;Hi!&#x27;, &#x27;Hi!&#x27;, &#x27;Hi!&#x27;)复制</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))<span class="comment">#True元素是否存在</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>): </span><br><span class="line">    <span class="built_in">print</span>(x)<span class="comment">#1 2 3迭代</span></span><br></pre></td></tr></table></figure><h4 id="元组索引"><a href="#元组索引" class="headerlink" title="元组索引"></a>元组索引</h4><p>因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素，如下所示。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup=(<span class="string">&#x27;sam&#x27;</span>,<span class="string">&#x27;lily&#x27;</span>,<span class="string">&#x27;lucy&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(tup[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(tup[-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(tup[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure><h4 id="无关闭分隔符"><a href="#无关闭分隔符" class="headerlink" title="无关闭分隔符"></a>无关闭分隔符</h4><p>任意无符号的对象，以逗号隔开，默认为元组。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;abc&#x27;</span>, -<span class="number">4.24e93</span>, <span class="number">18</span>+<span class="number">6.6j</span>, <span class="string">&#x27;xyz&#x27;</span>)</span><br><span class="line">x, y = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Value of x , y : &quot;</span>, x,y)</span><br><span class="line"><span class="comment">#abc -4.24e+93 (18+6.6j) xyz</span></span><br><span class="line"><span class="comment">#Value of x , y :  1 2</span></span><br></pre></td></tr></table></figure><h4 id="元组内置函数"><a href="#元组内置函数" class="headerlink" title="元组内置函数"></a>元组内置函数</h4><ol><li>cmp(tuple1, tuple2)【比较两个元组元素】</li><li>len(tuple)【计算元组元素个数】</li><li>max(tuple)【返回元组中元素最大值】</li><li>min(tuple)【返回元组中元素最小值】</li><li>tuple(seq)【将列表转换为元组】</li></ol><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典是另一种可变容器模型，且可存储任意类型对象。<br>字典的每个键值 key:value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中 ,格式如下所示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;key1 : value1, key2 : value2 &#125;</span><br></pre></td></tr></table></figure><ul><li>键一般是唯一的，如果重复最后的一个键值对会替换前面的，值不需要唯一。</li><li>值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。<br>一个简单的字典实例：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1=&#123;<span class="string">&#x27;Alice&#x27;</span>:<span class="string">&#x27;1234&#x27;</span>,<span class="string">&#x27;Beth&#x27;</span>:<span class="string">&#x27;4567&#x27;</span>,<span class="string">&#x27;Cecil&#x27;</span>:<span class="string">&#x27;9876&#x27;</span>&#125;</span><br><span class="line">dict2=&#123;<span class="string">&#x27;abc&#x27;</span>:<span class="number">456</span>&#125;</span><br><span class="line">dict3=&#123;<span class="string">&#x27;abc&#x27;</span>:<span class="number">123</span>,<span class="number">98.6</span>:<span class="number">37</span>&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="访问字典里的值"><a href="#访问字典里的值" class="headerlink" title="访问字典里的值"></a>访问字典里的值</h4><p>把相应的键放入熟悉的方括弧。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1=&#123;<span class="string">&#x27;Alice&#x27;</span>:<span class="string">&#x27;1234&#x27;</span>,<span class="string">&#x27;Beth&#x27;</span>:<span class="string">&#x27;4567&#x27;</span>,<span class="string">&#x27;Cecil&#x27;</span>:<span class="string">&#x27;9876&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>[<span class="string">&#x27;Alice&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>[<span class="string">&#x27;Cecil&#x27;</span>])</span><br></pre></td></tr></table></figure><p>如果用字典里没有的键访问数据，会输出错误如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1=&#123;<span class="string">&#x27;Alice&#x27;</span>:<span class="string">&#x27;1234&#x27;</span>,<span class="string">&#x27;Beth&#x27;</span>:<span class="string">&#x27;4567&#x27;</span>,<span class="string">&#x27;Cecil&#x27;</span>:<span class="string">&#x27;9876&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(dict1[<span class="string">&#x27;Lisa&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#  File &quot;D:/study/pythonstudy/test1.py&quot;, line 2, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#    print(dict1[&#x27;Lisa&#x27;])</span></span><br><span class="line"><span class="comment"># KeyError: &#x27;Lisa&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="修改字典"><a href="#修改字典" class="headerlink" title="修改字典"></a>修改字典</h4><p>向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对如下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1=&#123;<span class="string">&#x27;Alice&#x27;</span>:<span class="string">&#x27;1234&#x27;</span>,<span class="string">&#x27;Beth&#x27;</span>:<span class="string">&#x27;4567&#x27;</span>,<span class="string">&#x27;Cecil&#x27;</span>:<span class="string">&#x27;9876&#x27;</span>&#125;</span><br><span class="line">dict1[<span class="string">&#x27;Alice&#x27;</span>]=<span class="number">999</span></span><br><span class="line">dict1[<span class="string">&#x27;Beth&#x27;</span>]=<span class="number">888</span></span><br><span class="line"><span class="built_in">print</span>(dict1[<span class="string">&#x27;Alice&#x27;</span>]) <span class="comment">#999</span></span><br><span class="line"><span class="built_in">print</span>(dict1[<span class="string">&#x27;Beth&#x27;</span>]) <span class="comment">#888</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>刷题记录(坚持就是胜利）</title>
      <link href="/2022/09/30/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%9D%9A%E6%8C%81%E5%B0%B1%E6%98%AF%E8%83%9C%E5%88%A9%EF%BC%89/"/>
      <url>/2022/09/30/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E5%9D%9A%E6%8C%81%E5%B0%B1%E6%98%AF%E8%83%9C%E5%88%A9%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="算法设计与分析"><a href="#算法设计与分析" class="headerlink" title="算法设计与分析"></a>算法设计与分析</h1><h2 id="2-1-众数问题"><a href="#2-1-众数问题" class="headerlink" title="2-1 众数问题"></a>2-1 众数问题</h2><h3 id="（一）题目"><a href="#（一）题目" class="headerlink" title="（一）题目"></a>（一）题目</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定含有n个元素的多重集合S，每个元素在S中出现的次数称为该元素的重数。多重集S中重数最大的元素称为众数。例如：S={1,2,2,3,5}。多重集S的众数是2，其重数为3。</p><h4 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h4><p>对于给定的由n个自然数组成的多重集S，计算S的众数及其重数。</p><h4 id="数据输入"><a href="#数据输入" class="headerlink" title="数据输入"></a>数据输入</h4><p>输入数据由文件名为input.txt的文本文件提供。文件的第一行为多重集 中元素个数n，接下来的n行中，每行有一个自然数。</p><h4 id="结果输出"><a href="#结果输出" class="headerlink" title="结果输出"></a>结果输出</h4><p>将计算结果输出到文件output.txt。输出文件有两行，第1行是众数，第2行是重数。</p><h3 id="（二）解法"><a href="#（二）解法" class="headerlink" title="（二）解法"></a>（二）解法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModeTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读入txt文件函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] file2StringArray(File file) &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(file));</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span>( (str = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">int</span> number=Integer.parseInt(str);</span><br><span class="line">                list.add(number);</span><br><span class="line">            &#125;</span><br><span class="line">            br.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> ( IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] num=<span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        Integer[] int_arr=<span class="keyword">new</span> <span class="title class_">Integer</span>[list.size()];</span><br><span class="line">        int_arr=list.toArray(int_arr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;int_arr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            num[i]=int_arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//快速排序函数</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span>[] num,<span class="type">int</span> p,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> q=Partition(num,p,r);</span><br><span class="line">            QuickSort(num,p,q-<span class="number">1</span>);</span><br><span class="line">            QuickSort(num,q+<span class="number">1</span>,r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组分段</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">Partition</span><span class="params">(<span class="type">int</span>[] num,<span class="type">int</span> p,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i=p,j=r+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> x=num[p];</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(num[--j]&gt;x&amp;&amp;j&gt;<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span>(num[++i]&lt;=x);</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=j)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(num,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        num[p]=num[j];</span><br><span class="line">        num[j]=x;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] num,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> temp=num[i];</span><br><span class="line">        num[i]=num[j];</span><br><span class="line">        num[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找众数和其重数函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] findMaxCnt(<span class="type">int</span>[] num,<span class="type">int</span> l,<span class="type">int</span> r)&#123;</span><br><span class="line">        <span class="type">int</span>[] help=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];<span class="comment">//辅助数组，记录众数和众数重数</span></span><br><span class="line">        <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> pos_max;<span class="comment">//众数</span></span><br><span class="line">        <span class="type">int</span> cnt_max=<span class="number">0</span>;<span class="comment">//最大重数</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> pos_temp=<span class="number">0</span>;<span class="comment">//子序列划分点</span></span><br><span class="line">        <span class="type">int</span> cnt_temp=<span class="number">0</span>;<span class="comment">//子序列重数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以中位数为界限，划分为两段。</span></span><br><span class="line">        <span class="comment">//寻找左段右边界和右段左边界</span></span><br><span class="line">        <span class="type">int</span> midnum=num[mid];</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=l;i&lt;=r;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i]==midnum)&#123;</span><br><span class="line">                left=i-<span class="number">1</span>;<span class="comment">//找到左段的右边界</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;=r;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i]!=midnum)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right=i;<span class="comment">//找到右段的左边界</span></span><br><span class="line"></span><br><span class="line">        cnt_max=right-left-<span class="number">1</span>;<span class="comment">//众数的重数</span></span><br><span class="line">        pos_max=midnum;<span class="comment">//众数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//分治，判断左右两段的长度是否大于当前众数的重数</span></span><br><span class="line">        <span class="comment">//如果大于，说明有可能会更改众数</span></span><br><span class="line">        <span class="keyword">if</span>((left-l+<span class="number">1</span>)&gt;cnt_max)&#123;</span><br><span class="line">            cnt_temp=findMaxCnt(num,l,left)[<span class="number">1</span>];</span><br><span class="line">            pos_temp=findMaxCnt(num,l,left)[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(cnt_temp&gt;cnt_max)&#123;</span><br><span class="line">                pos_max=pos_temp;</span><br><span class="line">                cnt_max=cnt_temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((r-right+<span class="number">1</span>)&gt;cnt_max)&#123;</span><br><span class="line">            cnt_temp=findMaxCnt(num,right,r)[<span class="number">1</span>];</span><br><span class="line">            pos_max=findMaxCnt(num,right,r)[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(cnt_temp&gt;cnt_max)&#123;</span><br><span class="line">                pos_max=pos_temp;</span><br><span class="line">                cnt_max=cnt_temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新辅助数组的值</span></span><br><span class="line">        help[<span class="number">0</span>]=pos_max;</span><br><span class="line">        help[<span class="number">1</span>]=cnt_max;</span><br><span class="line">        <span class="keyword">return</span> help;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="comment">//读入文件，获取数组</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/study/大三上/算法/2_1_in.txt&quot;</span>);</span><br><span class="line">        <span class="type">int</span>[] A=file2StringArray(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先对数组进行排序，然后调用众数相关函数</span></span><br><span class="line">        ModeTest tt=<span class="keyword">new</span> <span class="title class_">ModeTest</span>();</span><br><span class="line">        tt.QuickSort(A,<span class="number">0</span>,A.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将结果输出到txt文件</span></span><br><span class="line">        PrintStream ps=<span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;D:/study/大三上/算法/2_1_out.txt&quot;</span>);</span><br><span class="line">        System.setOut(ps);</span><br><span class="line">        System.out.println(A[findMaxCnt(A,<span class="number">0</span>,A.length-<span class="number">1</span>)[<span class="number">0</span>]]);<span class="comment">//输出众数</span></span><br><span class="line">        System.out.println(+findMaxCnt(A,<span class="number">0</span>,A.length-<span class="number">1</span>)[<span class="number">1</span>]);<span class="comment">//输出重数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-3"><a href="#2-3" class="headerlink" title="2-3"></a>2-3</h2><p>题目：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HalfSet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">file2StringArray</span><span class="params">(File file)</span> &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(file));</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span>( (str = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                num=Integer.parseInt(str);</span><br><span class="line">            &#125;</span><br><span class="line">            br.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> ( IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用数组num来记录已经计算过的半数集，以此来避免重复计算</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">CountHalfSet</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span>[] num)</span>&#123;</span><br><span class="line">        <span class="comment">//已经记录过则直接调用</span></span><br><span class="line">        <span class="keyword">if</span>(num[n]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> num[n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没记录的，进行递归</span></span><br><span class="line">        <span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            sum+=CountHalfSet(i,num);</span><br><span class="line">        &#125;</span><br><span class="line">        num[n]=sum;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/study/大三上/算法/2_3_in.txt&quot;</span>);</span><br><span class="line">        <span class="type">int</span> number=file2StringArray(file);</span><br><span class="line">        HalfSet tt=<span class="keyword">new</span> <span class="title class_">HalfSet</span>();</span><br><span class="line">        <span class="type">int</span>[] num=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1000</span>];</span><br><span class="line">        PrintStream ps=<span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;D:/study/大三上/算法/2_3_out.txt&quot;</span>);</span><br><span class="line">        System.setOut(ps);</span><br><span class="line">        System.out.println(tt.CountHalfSet(number,num));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="leetcode动态规划"><a href="#leetcode动态规划" class="headerlink" title="leetcode动态规划"></a>leetcode动态规划</h2><h3 id="2022-10-03"><a href="#2022-10-03" class="headerlink" title="2022-10-03"></a>2022-10-03</h3><p>斐波那契数 （通常用 F(n) 表示）形成的序列称为斐波那契数列该数列由0和1开始，后面的每一项数字都是前面两项数字的和。也就是：<br>F(0)=0，F(1)= 1<br>F(n)=F(n-1)+F(n-2)，其中n&gt;1<br>给定n，请计算F(n)。</p><p>由于存在递推关系，可以使用动态规划求解。状态转移方程即为上述的递推关系，边界条件是F(0)&amp;F(1)。使用滚动数组思想。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> prev=<span class="number">1</span>,curr=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> sum=prev+curr;</span><br><span class="line">            prev=curr;</span><br><span class="line">            curr=sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2022-10-08"><a href="#2022-10-08" class="headerlink" title="2022-10-08"></a>2022-10-08</h3><p>泰波那契序列 Tn 定义如下： <br>T0 = 0, T1 = 1, T2 = 1, 且在 n &gt;= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2<br>给你整数 n，请返回第 n 个泰波那契数 Tn 的值。</p><p>泰波那契数的边界条件是 T(0)=0, T(1)=1, T(2)=1。当 n&gt;2 时，每一项的和都等于前三项的和，因此有如下递推关系：T(n)=T(n-1)+T(n-2)+T(n-3)。由于泰波那契数存在递推关系，因此可以使用动态规划求解。动态规划的状态转移方程即为上述递推关系，边界条件为T(0)、T(1)和T(2)。<br>使用所谓的”滚动数组思想”。为了填补i=3时循环的空缺，需要增加一个等于0的值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">tribonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num_n=<span class="number">0</span>,num_n1=<span class="number">0</span>,num_n2=<span class="number">1</span>,num_n3=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;           </span><br><span class="line">            num_n=num_n1;</span><br><span class="line">            num_n1=num_n2;</span><br><span class="line">            num_n2=num_n3;</span><br><span class="line">            num_n3=num_n+num_n1+num_n2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num_n3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2022-10-09"><a href="#2022-10-09" class="headerlink" title="2022-10-09"></a>2022-10-09</h3><p>假设你正在爬楼梯。需要n阶你才能到达楼顶。<br>每次你可以爬1或2个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>示例 1：<br>输入：n = 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶</li><li>2 阶<br>示例 2：</li></ol><p>输入：n = 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ol><p> <br>提示：<br>1 &lt;= n &lt;= 45</p><p>滚动数组思想<br>动态转移方程：f(x)=f(x−1)+f(x−2)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> step1=<span class="number">0</span>,step2=<span class="number">0</span>,step3=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            step1=step2;</span><br><span class="line">            step2=step3;</span><br><span class="line">            step3=step1+step2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2022-10-10"><a href="#2022-10-10" class="headerlink" title="2022-10-10"></a>2022-10-10</h3><p>设费用数组cost的长度为n，n个楼梯分别对应下标0~n-1。楼层顶部对应n。问题转化为计算从起点0或1到达n的最小代价。该问题具有最优子结构。<br>创建数组dp，长度为n+1，dp[i]代表达到下标i的最小代价。考虑到可以选择下标0或1作为起始，因此初始化dp[0]=dp[1]=0。</p><p><strong>对于2&lt;=i&lt;=n时，有两种爬楼梯方法。</strong></p><ol><li>从下标i-1，花费cost[i-1]到达下标i。</li><li>从下标i-2，花费cost[i-2]到达下标i。</li></ol><p>为求解最终答案，对每一个下标来说，dp[i]应该为这两者的最小值，由此可得如下状态方程。<br>dp[i]=min{dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]}<br>迭代计算dp中的每一项，最终得到dp[n]的值即为到达最顶层的最小代价。</p><p>具体代码如下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=cost.length;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>]; <span class="comment">//存放到达下标i的最小代价</span></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>; <span class="comment">//可以从0或者1出发，所以这两个值初始化为0</span></span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=Math.min(dp[i-<span class="number">1</span>]+cost[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+cost[i-<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n]; <span class="comment">//到达楼顶n的最小代价</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2022-10-11-打家劫舍"><a href="#2022-10-11-打家劫舍" class="headerlink" title="2022-10-11 打家劫舍"></a>2022-10-11 打家劫舍</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p>示例 1：<br>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 。</p><p>示例 2：<br>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p><p>提示：<br>1 &lt;= nums.length &lt;= 100<br>0 &lt;= nums[i] &lt;= 400</p><p>分步骤考虑。</p><ol><li>如果只有一间房子，选择偷窃。如果有两间房子，选择两个里面金额更高的偷窃。</li><li>第k个房子(k&gt;2)，在以下2种策略中选择金额较大的选项：<ul><li>偷窃第k间房子，不能偷k-1间房子，此时金额为偷窃<strong>前k-2间房屋累积的金额+偷窃第k间房子</strong>的金额。</li><li>不偷第k间房子，金额为<strong>前k-1间房子</strong>累积的金额。</li></ul></li></ol><p>创建dp[i]表示到达第k间房子时获得的金额，得到以下状态转移方程。<br>dp[i]=max{dp[i-2]+nums[i],dp[i-1]}<br>边界条件如下：<br>dp[0]=nums[0]<br>dp[1]=max{nums[0],nums[1]}<br>得到dp[n-1]即为所求答案。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;<span class="comment">//一共只有一间房子</span></span><br><span class="line">                <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//多个房子的情况</span></span><br><span class="line">            <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">            dp[<span class="number">0</span>]=nums[<span class="number">0</span>]; <span class="comment">//一间房子时只有一种策略</span></span><br><span class="line">            dp[<span class="number">1</span>]=Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]); <span class="comment">//两间房子时可以选择1号or2号房</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">                dp[i]=Math.max(dp[i-<span class="number">2</span>]+nums[i],dp[i-<span class="number">1</span>]); <span class="comment">//状态转移方程 任意房间i 有两种策略</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2022-10-12-打家劫舍Ⅱ"><a href="#2022-10-12-打家劫舍Ⅱ" class="headerlink" title="2022-10-12 打家劫舍Ⅱ"></a>2022-10-12 打家劫舍Ⅱ</h3><p>分情况考虑。</p><ol><li>假设只有一间房子，则偷窃这个房子，金额就是能够获得的最大的金额。</li><li>假设有两间房子，只能偷窃其中之一，选其中金额更大的进行偷窃。</li></ol><p>以上两种情况只能偷窃一间房子，不用考虑首尾相连情况。</p><ol start="3"><li>超过两间房子时，分为两种情况。<br>a. 偷了第一间，不能偷最后一间只能偷到倒数第二间。范围为第一间到倒数第二间。<br>b. 偷了最后一间，不能偷第一间只能从第二间开始偷。范围为第二间到最后一间。</li></ol><p>设数组nums长度为n，则3a的偷窃范围为[0,n-2]，3b的偷窃范围为[1,n-1]。考虑对打家劫舍简单版的代码进行改进，设置出下标的范围（起始与结束，之后就能套用）最终的总金额即为在这两种里面挑选最大的一种。</p><p>创建dp[i]表示到达第k间房子时获得的金额，得到以下状态转移方程。<br>dp[i]=max{dp[i-2]+nums[i],dp[i-1]}</p><p>边界条件：<br>dp[start]=nums[start]<br>dp[start+1]=max{nums[start],nums[start+1]}</p><p>取[0,n-2]，[1,n-1]为[start,end]，计算出两个里面最大的，得到dp[end]即为所求答案。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123; <span class="comment">//只有一间房子</span></span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.length==<span class="number">2</span>)&#123; <span class="comment">//两间房子选金额最大的</span></span><br><span class="line">            <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=Math.max(robhelp(<span class="number">0</span>,nums.length-<span class="number">2</span>,nums),robhelp(<span class="number">1</span>,nums.length-<span class="number">1</span>,nums));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">robhelp</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> one=nums[start]; <span class="comment">//起始的第一间房</span></span><br><span class="line">        <span class="type">int</span> two=Math.max(nums[start],nums[start+<span class="number">1</span>]); <span class="comment">//起始的第二间房</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start+<span class="number">2</span>;i&lt;=end;i++)&#123; <span class="comment">//从起始的第三间房开始，迭代到最后一间房</span></span><br><span class="line">            <span class="type">int</span> temp=two;</span><br><span class="line">            two=Math.max(one+nums[i],two);</span><br><span class="line">            one=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> two;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习笔记</title>
      <link href="/2022/09/29/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/09/29/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux学习笔记（摸索ing）"><a href="#Linux学习笔记（摸索ing）" class="headerlink" title="Linux学习笔记（摸索ing）"></a>Linux学习笔记（摸索ing）</h1><h2 id="Linux命令大全"><a href="#Linux命令大全" class="headerlink" title="Linux命令大全"></a>Linux命令大全</h2><p>常见命令<br>ls/cd/pwd<br>mkdir/rmdir<br>cp/rm/mv<br>tar/zip/unzip<br>ln…</p><h3 id="文件列表"><a href="#文件列表" class="headerlink" title="文件列表"></a>文件列表</h3><ol><li>ls 以详细样式查看<br>ls -l /home/charyeon 展示home/charyeon目录下文件（包括文件属性）</li></ol><h3 id="切换目录"><a href="#切换目录" class="headerlink" title="切换目录"></a>切换目录</h3><ol><li>pwd print working directory显示当前位置</li><li>cd change direcotry切换目录<br>cd /home/charyeon/example<br>cd ~ 切换到主目录<br>cd ./example切换到当前目录<br>cd .. 切换到上级目录<br>cd ~/example 切换到主目录下的example目录<br>cd ../www 切换到上级目录，再到www子目录<br>ls ~<br>ls ./www </li></ol><p><strong>几个特殊的目录</strong><br>  ~ 代表当前用户的主目录<br>  . 代表当前目录<br>  .. 代表上一级目录</p><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><ol><li><p>mkdir make directory<br>mkdir abc<br>mkdir -p abc/123/test<br>设置-p参数，将路径的层次全部创建</p></li><li><p>rmdir remove directory<br>rmdir abc<br>如果目录非空，则删除失败</p></li><li><p>rm remove删除文件或者目录<br>rm -rf abc<br>删除abc目录，连带着子项一起删除<br>r：recursive，f：force</p></li><li><p>cp copy复制文件或目录<br>cp -rf example example2<br>复制example并命名为example2</p></li><li><p>mv move移动文件或目录（重命名）<br>move hello helloworld<br>把hello重命名为helloworld</p></li></ol><h3 id="归档"><a href="#归档" class="headerlink" title="归档"></a>归档</h3><ol><li><p>tar tape archive 档案打包<br>tar -cvf example.tar example 把example打包从成example.tar<br>c：create 创建档案<br>v：verbose 显示详情<br>f：file<br>也可以多个目录打包 tar -cvf xxx.tar file1 file2 file3</p></li><li><p>还原档案包<br>tar -xvf example.tar<br>tar -xvf example.tar -C outdir<br>x：extract -C参数指定目标目录，默认解到当前目录下<br>以上两个操作只是归档但没有压缩，文件依然会比较大</p></li><li><p>归档并压缩<br>tar -zcvf example.tar.gz example<br>tar -zxvf example.tar.gz<br>tar -zxvf example.tar.gz -C outdir<br>通常见到的都为*.tar.gz格（标准压缩包格式）</p></li></ol><h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><p>  即Windows下的快捷方式，使用ln（link）命令来创建软链接<br>  ln -s source link<br>  -s：表示soft软链接（默认为硬）<br>  ln -s example example2</p><p>软链接的特点：</p><ol><li>删除软链接对原文件无影响</li><li>删除源文件则软链接失效</li></ol><p>  以 ls -l查看文件详情使可以看到目标路径（快捷方式指向文件）<br>  例如bin是usr/bin的软链接</p><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><ol><li>添加一个用户<br>sudo useradd -m test1<br>sudo：以管理员身份执行</li></ol><p>-m：表示在/home下添加用户目录</p><ol start="2"><li><p>修改密码<br>sudo passwd test1</p></li><li><p>删除用户<br>sudo userdel test1<br>sudo rm -rf /home/test1/ 同时删除主目录下的用户<br>只有特殊用户可执行sudo，把这种用户称为sudoer</p></li></ol><h3 id="超级用户"><a href="#超级用户" class="headerlink" title="超级用户"></a>超级用户</h3><p>超级用户root，类似于Windows系统下的Adminstrator用户。切换到root用户有全部权限，可以直接使用useradd等命令。</p><ol><li><p>首次使用需要给root设置密码<br>sudo passwd root</p></li><li><p>切换到root用户<br>su root 仅对当前会话终端有效，不影响当前桌面环境<br>su：switch user</p></li><li><p>退出<br>exit</p></li></ol><h3 id="用户和组"><a href="#用户和组" class="headerlink" title="用户和组"></a>用户和组</h3><p>Linux下可以创建多个用户，用组进行管理用户，每个组有不同的权限。一般用户不多的时候，不太使用组的概念。默认创建一个用户时会创建一个同名的组，也就是说默认这个组里只有他一个人。<br>比如划分为男生组boys【含ming bo gang qiang】，女生组girls【含fang hong yue yuan】。</p><ol><li><p>创建组<br>groupadd boys</p></li><li><p>创建用户<br>useradd -m -g boys ming</p></li></ol><p>-g：添加用户，并将用户加到boys组</p><ol start="3"><li><p>修改用户组别<br>usermod -g boys charyeon<br>mod：modified简称</p></li><li><p>查看用户和组<br>cat /etc/group<br>每一行表示一个group的信息，名称+ID</p></li><li><p>查看用户列表<br>cat /etc/passwd<br>每一行表示一个用户的信息</p></li></ol><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><ul><li>owner：文件的属主</li><li>r：文件是否可读</li><li>w：文件是否可写</li><li>x：文件是否可执行</li></ul><p>使用 Linux 时，通过命令行输入 ls -l / 可以看到，在 Linux 根目录（/）下包含很多的子目录（称为一级目录），例如 bin、boot、dev 等。同时，各一级目录下还含有很多子目录（称为二级目录），比如 /bin/bash、/bin/ed 等。Linux 文件系统目录总体呈现树形结构，/ 根目录就相当于树根。<br>为了避免诸多使用者对 Linux 系统目录结构天马行空，Linux 基金会发布了 FHS 标准。多数 Linux 发行版系统都遵循这一标准。<br>FHS（Filesystem Hierarchy Standard），文件系统层次化标准，该标准规定了 Linux 系统中所有一级目录以及部分二级目录（/usr 和 /var）的用途。发布此标准的主要目的就是为了让用户清楚地了解每个目录应该存放什么类型的文件。</p><h2 id="Linux根目录（-）"><a href="#Linux根目录（-）" class="headerlink" title="Linux根目录（/）"></a>Linux根目录（/）</h2><p>Linux 系统的根目录（/）最为重要，包含开机软件、核心文件、开机所需程序、函数库、修复系统程序等文件。</p><ul><li>/bin/<br>存放系统命令，普通用户和 root 都可以执行。放在 /bin 下的命令在单用户模式下也可以执行</li><li>/boot/<br>系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序（grub）文件等</li><li>/dev/<br>设备文件保存位置</li><li>/etc/<br>配置文件保存位置。系统内所有采用默认安装方式（rpm 安装）的服务配置文件全部保存在此目录中，如用户信息、服务的启动脚本、常用服务的配置文件等</li><li>/home/<br>普通用户的主目录（也称为家目录）。在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的主目录，所有普通用户的主目录是在 /home/ 下建立一个和用户名相同的目录。如用户 Jupiter 的主目录就是 /home/Jupiter</li><li>/lib/<br>系统调用的函数库保存位置</li><li>/media/<br>挂载目录。系统建议用来挂载媒体设备，如软盘和光盘</li><li>/mnt/<br>挂载目录。早期 Linux 中只有这一个挂载目录，并没有细分。系统建议这个目录用来挂载额外的设备，如 U 盘、移动硬盘和其他操作系统的分区</li><li>/misc/<br>挂载目录。系统建议用来挂载 NFS 服务的共享目录。虽然系统准备了三个默认挂载目录 /media/、/mnt/、/misc/，但是到底在哪个目录中挂载什么设备可以由管理员自己决定。例如，参考者在接触 Linux 的时候，默认挂载目录只有 /mnt/，所以养成了在 /mnt/ 下建立不同目录挂载不同设备的习惯，如 /mnt/cdrom/ 挂载光盘、/mnt/usb/ 挂载 U 盘，都是可以的</li><li>/opt/<br>第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。不过/usr/local/ 目录也可以用来安装软件</li><li>/root/<br>root 的主目录。普通用户主目录在 /home/ 下，root 主目录直接在“/”下</li><li>/sbin/<br>保存与系统环境设置相关的命令，只有 root 可以使用这些命令进行系统环境设置，但也有些命令可以允许普通用户查看</li><li>/srv/<br>服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据</li><li>/tmp/<br>临时目录。系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入。建议此目录中不能保存重要数据，最好每次开机都把该目录清空。</li></ul><h2 id="Linux-usr目录"><a href="#Linux-usr目录" class="headerlink" title="Linux /usr目录"></a>Linux /usr目录</h2><p>usr，全称为 Unix Software Resource，此目录用于存储系统软件资源。FHS 建议所有开发者，应把软件产品的数据合理的放置在 /usr 目录下的各子目录中，而不是为他们的产品创建单独的目录。<br>Linux 系统中，所有系统默认的软件都存储在 /usr 目录下，/usr 目录类似 Windows 系统中 C:\Windows\ + C:\Program files\ 两个目录的综合体。<br>FHS 建议，/usr 目录应具备表 3 所示的子目录。</p><ul><li>/usr/bin/<br>存放系统命令，普通用户和超级用户都可以执行。这些命令和系统启动无关，在单用户模式下不能执行。</li><li>/usr/sbin/<br>存放根文件系统不必要的系统管理命令，如多数服务程序，只有 root 可以使用。</li><li>/usr/lib/<br>应用程序调用的函数库保存位置</li><li>/usr/XllR6/<br>图形界面系统保存位置</li><li>/usr/local/<br>手工安装的软件保存位置。一般建议源码包软件安装在这个位置。</li><li>/usr/share/<br>应用程序的资源文件保存位置，如帮助文档、说明文档和字体目录。</li><li>/usr/src/<br>源码包保存位置。我们手工下载的源码包和内核源码包都可以保存到这里。不过一般更习惯把手工下载的源码包保存到 /usr/local/src/ 目录中，把内核源码保存到 /usr/src/linux/ 目录中</li><li>/usr/include<br>C/C++ 等编程语言头文件的放置目录</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora学习笔记</title>
      <link href="/2022/09/05/Typora%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2022/09/05/Typora%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一-文字处理"><a href="#一-文字处理" class="headerlink" title="一.文字处理"></a>一.文字处理</h1><ol><li><strong>标题</strong> 标题一共有六级,是用“#”实现的，标题前面加一个“#”，代表一级标题；依次类推，标题前面加六个“#”代表六级标题；一共有六级标题，编辑各种文档完全够用,左侧的目录会根据输入的标题自动生成响应的层级。</li><li><strong>强调</strong> 在要强调内容前后分别加两个“*”号。</li><li><strong>斜体</strong> 前后分别加一个“*”号。</li><li><strong>删除线</strong> 内容前后分别加上两个“~”号。</li><li><strong>分割线</strong> 输入三个或三个以上“-”（“*”），再按回车键，即出现一条分割线。</li><li><strong>插入</strong> 插入本地图片：直接把图片拖入即可； 插入网络图片：![图片标题]（图片链接）<br>选择本地文件或者输入url地址都可以。</li><li><strong>链接</strong> [链接提示]+(链接地址)</li><li><strong>数学公式</strong> “$$”+回车。</li><li><strong>代码</strong><br>行内代码：代码的两端各加一个“`”号，（在Tab键上面，英文输入法）。<br>代码块：输入三个“~”，按回车键，即可选择编程语言。</li></ol><h1 id="二-list列表处理"><a href="#二-list列表处理" class="headerlink" title="二.list列表处理"></a>二.list列表处理</h1><ol><li><strong>有序列表</strong> 输入数字“1”+“.”+空格 ， 自动开始有序列表。</li><li><strong>无序列表</strong>输入“+”或“-”或“*”+空格，自动开始无序列表。</li><li><strong>table表格</strong> Ctrl+T,在弹出的对话框中选择行列数，自动生成列表。 还可以很方便地对表格进行编辑。当然还有另外一种建立表格的方式用’|’分隔然后回车创建表格（首尾都需要添加）,使用ctrl+回车新添一行。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git报错合集【持续更新···】</title>
      <link href="/2022/08/22/git%E6%97%B6%E6%8A%A5%E9%94%99/"/>
      <url>/2022/08/22/git%E6%97%B6%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<h1 id="Git报错合集"><a href="#Git报错合集" class="headerlink" title="Git报错合集"></a>Git报错合集</h1><h2 id="OpenSSL-SSL-connect-Connection-was-reset-in-connection-to-git-com-443"><a href="#OpenSSL-SSL-connect-Connection-was-reset-in-connection-to-git-com-443" class="headerlink" title="OpenSSL SSL_connect: Connection was reset in connection to git.com:443"></a>OpenSSL SSL_connect: Connection was reset in connection to git.com:443</h2><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>使用git进行pull和push时，报错如下：</p><p>OpenSSL SSL_connect: Connection was reset in connection to git.com:443</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在git bash中输入以下命令：<br>(第二个命令双引号内路径换成git安装路径)</p><pre><code>git config --global http.sslBackend &quot;openssl&quot;git config --global http.sslCAInfo &quot;D:\software\Git\mingw64\ssl\cert.pem&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Git </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常见问题 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Nunjucks Error:问题原因及解决</title>
      <link href="/2022/08/18/Hexo-Nunjucks-Error-%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
      <url>/2022/08/18/Hexo-Nunjucks-Error-%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>在学习开发小程序过程中，记录了一些内容。随后，尝试hexo s，但是出现如下报错：</p><img src="/2022/08/18/Hexo-Nunjucks-Error-%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3/Nunjunks.png" class="" title="报错"><p>改了半天，发现是"{{}}"有问题：<img src="/2022/08/18/Hexo-Nunjucks-Error-%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3/Nunjunks2.png" class="" title="报错">解决方法如下：将"{{}}"替换为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% raw %&#125;&quot;&#123;&#123;&#125;&#125;&quot;&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
          <category> 问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序开发随记</title>
      <link href="/2022/08/18/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%9A%8F%E8%AE%B0/"/>
      <url>/2022/08/18/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%9A%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="微信小程序开发随记"><a href="#微信小程序开发随记" class="headerlink" title="微信小程序开发随记"></a>微信小程序开发随记</h1><p>目前主要是参考了官方文档</p><h2 id="小程序代码构成"><a href="#小程序代码构成" class="headerlink" title="小程序代码构成"></a>小程序代码构成</h2><p>首先去官方申请小程序账号，然后安装开发者工具，新建项目；之后，会发现项目里自动生成了不同类型的文件。</p><ol><li>.json 后缀的 JSON 配置文件</li><li>.wxml 后缀的 WXML 模板文件</li><li>.wxss 后缀的 WXSS 样式文件</li><li>.js 后缀的 JS 脚本逻辑文件</li></ol><h3 id="JSON-配置"><a href="#JSON-配置" class="headerlink" title="JSON 配置"></a>JSON 配置</h3><p>JSON 是一种数据格式，并不是编程语言，在小程序中，JSON扮演的静态配置的角色。我们可以看到在项目的根目录有一个 <strong>app.json</strong> 和 <strong>project.config.json</strong>，此外在 <strong>pages/logs</strong> 目录下还有一个 <strong>logs.json</strong>，我们依次来说明一下它们的用途。</p><h4 id="小程序配置-app-json"><a href="#小程序配置-app-json" class="headerlink" title="小程序配置 app.json"></a>小程序配置 app.json</h4><p><strong>app.json</strong> 是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。QuickStart 项目里边的 <strong>app.json</strong> 配置内容如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;pages&quot;</span>:[</span><br><span class="line">    <span class="string">&quot;pages/index/index&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pages/logs/logs&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;window&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;backgroundTextStyle&quot;</span>:<span class="string">&quot;light&quot;</span>,</span><br><span class="line">    <span class="string">&quot;navigationBarBackgroundColor&quot;</span>: <span class="string">&quot;#fff&quot;</span>,</span><br><span class="line">    <span class="string">&quot;navigationBarTitleText&quot;</span>: <span class="string">&quot;Weixin&quot;</span>,</span><br><span class="line">    <span class="string">&quot;navigationBarTextStyle&quot;</span>:<span class="string">&quot;black&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个配置各个项的含义:</p><ol><li>pages字段：描述当前小程序所有页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录。</li><li>window字段：定义小程序所有页面的顶部背景颜色，文字颜色定义等。</li></ol><h4 id="工具配置-project-config-json"><a href="#工具配置-project-config-json" class="headerlink" title="工具配置 project.config.json"></a>工具配置 project.config.json</h4><p>通常大家在使用一个工具的时候，都会针对各自喜好做一些个性化配置，例如界面颜色、编译配置等等，当你换了另外一台电脑重新安装工具的时候，你还要重新配置。</p><p>考虑到这点，小程序开发者工具在每个项目的根目录都会生成一个 <strong>project.config.json</strong>，你在工具上做的任何配置都会写入到这个文件，当你重新安装工具或者换电脑工作时，你只要载入同一个项目的代码包，开发者工具就自动会帮你恢复到当时你开发项目时的个性化配置，其中会包括编辑器的颜色、代码上传时自动压缩等等一系列选项。</p><h4 id="页面配置-page-json"><a href="#页面配置-page-json" class="headerlink" title="页面配置 page.json"></a>页面配置 page.json</h4><p>这里的 <strong>page.json</strong> 其实用来表示 pages/logs 目录下的 <strong>logs.json</strong> 这类和小程序页面相关的配置。</p><p>如果你整个小程序的风格是蓝色调，那么你可以在 app.json 里边声明顶部颜色是蓝色即可。实际情况可能不是这样，可能你小程序里边的每个页面都有不一样的色调来区分不同功能模块，因此我们提供了 page.json，让开发者可以独立定义每个页面的一些属性，例如刚刚说的顶部颜色、是否允许下拉刷新等等。</p><h4 id="JSON简单语法"><a href="#JSON简单语法" class="headerlink" title="JSON简单语法"></a>JSON简单语法</h4><p>JSON文件都是被包裹在一个大括号中 {}，通过 key-value 的方式来表达数据。JSON的 Key 必须包裹在一个<strong>双引号</strong>中，在实践中，编写 JSON 的时候，忘了给 Key 值加双引号或者是把双引号写成单引号是常见错误。需要注意的是 JSON 文件中无法使用注释，试图添加注释将会引发报错。<br>JSON的值只能是以下几种数据格式，其他任何格式都会触发报错，例如 JavaScript 中的 undefined。</p><ol><li>数字，包含浮点数和整数</li><li>字符串，需要包裹在双引号中</li><li>Bool值，true 或者 false</li><li>数组，需要包裹在方括号中 []</li><li>对象，需要包裹在大括号中 {}</li><li>Null</li></ol><h3 id="WXML-模板"><a href="#WXML-模板" class="headerlink" title="WXML 模板"></a>WXML 模板</h3><p>网页编程采用的是 <strong>HTML + CSS + JS</strong> 这样的组合，其中 <strong>HTML</strong> 是用来描述当前这个页面的结构，<strong>CSS</strong> 用来描述页面的样子，<strong>JS</strong> 通常是用来处理这个页面和用户的交互。</p><p>同样道理，在小程序中也有同样的角色，其中 <strong>WXML</strong> 充当的就是类似 HTML 的角色。打开 <strong>pages/index/index.wxml</strong>，你会看到以下的内容:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;userinfo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;&quot;</span>&gt;</span> 获取头像昵称 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:else</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;userInfo.avatarUrl&#125;&#125;&quot;</span> <span class="attr">background-size</span>=<span class="string">&quot;cover&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">&quot;userinfo-nickname&quot;</span>&gt;</span>&#123;&#123;userInfo.nickName&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;usermotto&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">&quot;user-motto&quot;</span>&gt;</span>&#123;&#123;motto&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>和 <strong>HTML</strong> 非常相似，<strong>WXML</strong> 由标签、属性等等构成。但是也有很多不一样的地方，如下：</p><ol><li>标签名字不一样<br>写 <strong>HTML</strong> 的时候，经常会用到的标签是 div, p, span，开发者在写一个页面的时候可以根据这些基础的标签组合出不一样的组件，例如日历、弹窗等等。<strong>wxml</strong>中，把这些常用的组件包装了起来，提高了开发效率。<br>小程序的 <strong>WXML</strong> 用的标签是 <strong>view</strong>, <strong>button</strong>, <strong>text</strong> 等等，这些标签就是小程序给开发者包装好的基本能力，我们还提供了地图、视频、音频等等组件能力。</li><li>多了一些 <strong>wx:if</strong> 这样的属性以及 "{{}}" 这样的表达式在网页的一般开发流程中，我们通常会通过 **JS** 操作 **DOM** (对应 HTML 的描述产生的树)，以引起界面的一些变化响应用户的行为。例如，用户点击某个按钮的时候，**JS** 会记录一些状态到 **JS** 变量里边，同时通过 **DOM** API 操控 **DOM** 的属性或者行为，进而引起界面一些变化。当项目越来越大的时候，你的代码会充斥着非常多的界面交互逻辑和程序的各种状态变量，显然这不是一个很好的开发模式，因此就有了 **MVVM** 的开发模式（例如 React, Vue），提倡把渲染和逻辑分离。*简单来说就是不要再让 **JS** 直接操控 **DOM**，**JS** 只需要管理状态即可，然后再通过一种模板语法来描述状态和界面结构的关系即可。*如果你需要把一个 Hello World 的字符串显示在界面上,**WXML** 是这么写:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;text&gt;&#123;&#123;msg&#125;&#125;&lt;/text&gt;</span><br></pre></td></tr></table></figure>**JS** 只需要管理状态即可:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.setData(&#123; msg: &quot;Hello World&quot; &#125;)</span><br></pre></td></tr></table></figure>通过 "{{}}" 的语法把一个变量绑定到界面上，我们称为数据绑定。仅仅通过数据绑定还不够完整的描述状态和界面的关系，还需要 <strong>if/else</strong>, <strong>for</strong>等控制能力，在小程序里边，这些控制能力都用 <strong>wx:</strong> 开头的属性来表达。</li></ol><h3 id="WXSS-样式"><a href="#WXSS-样式" class="headerlink" title="WXSS 样式"></a>WXSS 样式</h3><p><strong>WXSS</strong> 具有 <strong>CSS</strong> 大部分的特性，小程序在 <strong>WXSS</strong> 也做了一些扩充和修改。</p><ol><li>新增了尺寸单位：在写 <strong>CSS</strong> 样式时，开发者需要考虑到手机设备的屏幕会有不同的宽度和设备像素比，采用一些技巧来换算一些像素单位。<strong>WXSS</strong> 在底层支持新的尺寸单位 <strong>rpx</strong> ，开发者可以免去换算的烦恼，只要交给小程序底层来换算即可，由于换算采用的浮点数运算，所以运算结果会和预期结果有一点点偏差。</li><li>提供了全局的样式和局部样式：和前边 <strong>app.json</strong>, <strong>page.json</strong> 的概念相同，你可以写一个 <strong>app.wxss</strong> 作为全局样式，会作用于当前小程序的所有页面，局部页面样式 <strong>page.wxss</strong> 仅对当前页面生效。</li><li>此外 <strong>WXSS</strong> 仅支持部分 <strong>CSS</strong> 选择器</li></ol><h3 id="JS-逻辑交互"><a href="#JS-逻辑交互" class="headerlink" title="JS 逻辑交互"></a>JS 逻辑交互</h3><p>一个服务仅仅只有界面展示是不够的，还需要和用户做交互：响应用户的点击、获取用户的位置等等。在小程序里边，我们就通过编写 <strong>JS</strong> 脚本文件来处理用户的操作。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">&quot;clickMe&quot;</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击 <strong>button</strong> 按钮的时候，我们希望把界面上 <strong>msg</strong> 显示成 “Hello World”，于是我们在 <strong>button</strong> 上声明一个属性: <strong>bindtap</strong> ，在 JS 文件里边声明了 <strong>clickMe</strong> 方法来响应这次点击操作：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="attr">clickMe</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123; <span class="attr">msg</span>: <span class="string">&quot;Hello World&quot;</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此外你还可以在 <strong>JS</strong> 中调用小程序提供的丰富的 API，利用这些 API 可以很方便的调起微信提供的能力，例如获取用户信息、本地存储、微信支付等。在前边的例子中，在 <strong>pages/index/index.js</strong> 就调用了 <strong>wx.getUserInfo</strong> 获取微信用户的头像和昵称，最后通过 <strong>setData</strong> 把获取到的信息显示到界面上。</p><h2 id="小程序宿主环境"><a href="#小程序宿主环境" class="headerlink" title="小程序宿主环境"></a>小程序宿主环境</h2><p>我们称微信客户端给小程序所提供的环境为宿主环境。小程序借助宿主环境提供的能力，可以完成许多普通网页无法完成的功能。</p><p>上一章中我们把小程序涉及到的文件类型阐述了一遍，我们接下来讲一下这些文件是怎么配合工作的。</p><h3 id="渲染层和逻辑层"><a href="#渲染层和逻辑层" class="headerlink" title="渲染层和逻辑层"></a>渲染层和逻辑层</h3><p>首先，我们来简单了解下小程序的运行环境。小程序的运行环境分成渲染层和逻辑层，其中 <strong>WXML</strong> 模板和 <strong>WXSS</strong> 样式工作在渲染层，<strong>JS</strong> 脚本工作在逻辑层。<br>小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了<strong>WebView</strong> 进行渲染；逻辑层采用 <strong>JsCore</strong> 线程运行 <strong>JS</strong> 脚本。一个小程序存在多个界面，所以渲染层存在多个 <strong>WebView</strong> 线程，这两个线程的通信会经由微信客户端（下文中也会采用 <strong>Native</strong> 来代指微信客户端）做中转，逻辑层发送网络请求也经由 <strong>Native</strong> 转发，小程序的通信模型下图所示：</p><img src="/2022/08/18/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%9A%8F%E8%AE%B0/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%80%9A%E4%BF%A1%E6%A8%A1%E6%9D%BF.png" class="" title="小程序通信模板"><h3 id="程序与页面"><a href="#程序与页面" class="headerlink" title="程序与页面"></a>程序与页面</h3><p>微信客户端在打开小程序之前，会把整个小程序的代码包下载到本地。<br>紧接着通过 app.json 的 pages 字段就可以知道你当前小程序的所有页面路径:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;pages&quot;</span>:[</span><br><span class="line">    <span class="string">&quot;pages/index/index&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pages/logs/logs&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置说明在项目定义了两个页面，分别位于 <strong>pages/index/index</strong> 和 <strong>pages/logs/logs</strong>。而写在 <strong>pages</strong> 字段的第一个页面就是这个小程序的首页（打开小程序看到的第一个页面）。<br>于是微信客户端就把首页的代码装载进来，通过小程序底层的一些机制，就可以渲染出这个首页。<br>小程序启动之后，在 <strong>app.js</strong> 定义的 App 实例的 onLaunch 回调会被执行:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">App</span>(&#123;</span><br><span class="line">  <span class="attr">onLaunch</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 小程序启动之后 触发</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>整个小程序只有一个 App 实例，是全部页面共享的。<br>接下来我们简单看看小程序的一个页面是怎么写的。<br>你可以观察到 <strong>pages/logs/logs</strong> 下其实是包括了4种文件的，微信客户端会先根据 <strong>logs.json</strong> 配置生成一个界面，顶部的颜色和文字你都可以在这个 json 文件里边定义好。紧接着客户端就会装载这个页面的 <strong>WXML 结构</strong>和 <strong>WXSS 样式</strong>。最后客户端会装载 <strong>logs.js</strong>，你可以看到 <strong>logs.js</strong> 的大体内容就是:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123; <span class="comment">// 参与页面渲染的数据</span></span><br><span class="line">    <span class="attr">logs</span>: []</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">onLoad</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 页面渲染后 执行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>Page</strong> 是一个页面构造器，这个构造器就生成了一个页面。在生成页面的时候，小程序框架会把 <strong>data</strong> 数据和 <strong>index.wxml</strong> 一起渲染出最终的结构，于是就得到了你看到的小程序的样子。</p><p>在渲染完界面之后，页面实例就会收到一个 <strong>onLoad</strong> 的回调，你可以在这个回调处理你的逻辑。</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>小程序提供了丰富的基础组件给开发者，开发者可以像搭积木一样，组合各种组件拼合成自己的小程序。</p><p>就像 *<strong>HTML</strong> 的 **<strong>div</strong>, <strong>p</strong> 等标签一样，在小程序里边，你只需要在 <strong>WXML</strong> 写上对应的组件标签名字就可以把该组件显示在界面上，例如，你需要在界面上显示地图，你只需要这样写即可：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;map&gt;&lt;/map&gt;</span><br></pre></td></tr></table></figure><p>使用组件的时候，还可以通过<strong>属性</strong>传递值给组件，让组件可以以不同的状态去展现，例如，我们希望地图一开始的中心的经纬度是上海，那么你需要声明地图的 longitude（中心经度） 和 latitude（中心纬度）两个属性:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;map longitude=&quot;上海经度&quot; latitude=&quot;上海纬度&quot;&gt;&lt;/map&gt;</span><br></pre></td></tr></table></figure><p>组件的内部行为也会通过事件的形式让开发者可以感知，例如用户点击了地图上的某个标记，你可以在 js 编写 markertap 函数来处理：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;map bindmarkertap=<span class="string">&quot;markertap&quot;</span> longitude=<span class="string">&quot;上海经度&quot;</span> latitude=<span class="string">&quot;上海纬度&quot;</span>&gt;&lt;/map&gt;</span><br></pre></td></tr></table></figure><p>当然你也可以通过 <strong>style</strong> 或者 <strong>class</strong> 来控制组件的外层样式，以便适应你的界面宽度高度等等。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>为了让开发者可以很方便的调起微信提供的能力，例如获取用户信息、微信支付等等，小程序提供了很多 API 给开发者去使用。<br>要获取用户的地理位置时，只需要：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wx.getLocation(&#123;</span><br><span class="line">  type: &#x27;wgs84&#x27;,</span><br><span class="line">  success: (res) =&gt; &#123;</span><br><span class="line">    var latitude = res.latitude // 纬度</span><br><span class="line">    var longitude = res.longitude // 经度</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>调用微信扫一扫能力，只需要：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wx.scanCode(&#123;</span><br><span class="line">  success: (res) =&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>需要注意的是：多数 API 的回调都是异步，你需要处理好代码逻辑的异步问题。</p><h2 id="小程序协同工作和发布"><a href="#小程序协同工作和发布" class="headerlink" title="小程序协同工作和发布"></a>小程序协同工作和发布</h2><p>多数情况下，一个团队多人同时参与同一个小程序项目，每个角色所承担的工作或者权限不一样，中大公司的分工更为仔细。为了更形象的表达团队不同角色的关系以及权限的管理，我们通过虚拟一个项目成员组织结构来描述日常如何协同合作完成一个小程序的发布，组织关系如图。</p><img src="/2022/08/18/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%9A%8F%E8%AE%B0/%E5%9B%A2%E9%98%9F%E6%9E%B6%E6%9E%84.png" class="" title="团队架构"><p><strong>项目管理</strong>成员负责统筹整个项目的进展和风险、把控小程序对外发布的节奏，<strong>产品组</strong>提出需求，<strong>设计组</strong>与产品讨论并对需求进行抽象，设计出可视化流程与图形，输出设计方案。<strong>开发组</strong>依据设计方案，进行程序代码的编写，代码编写完成后，<strong>产品组</strong>与<strong>设计组</strong>体验小程序的整体流程，<strong>测试组</strong>编写测试用例并对小程序进行各种边界测试。项目一般的成员构成与工作流程如图。</p><img src="/2022/08/18/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%9A%8F%E8%AE%B0/%E6%B5%81%E7%A8%8B.png" class="" title="小程序发布流程">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 项目 </tag>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab学习笔记</title>
      <link href="/2022/08/11/Matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/08/11/Matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>主要是为了准备数模，复习一下清风老师的课程。</p><h1 id="Matlab语法"><a href="#Matlab语法" class="headerlink" title="Matlab语法"></a>Matlab语法</h1><h2 id="一-基本小常识"><a href="#一-基本小常识" class="headerlink" title="一.基本小常识"></a>一.基本小常识</h2><h3 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h3><ol><li>a=2+3 ans=5<br>a=2+3; 无输出</li><li>多行注释 Ctrl+R</li><li>取消注释 Ctrl+T</li><li>clear可以清楚工作区的所有变量</li><li>clc可以清除命令行窗口中的所有文本</li><li>注意Matlab的数组中不能保存字符串，如果要生成字符串数组，就需要使用元胞数组，其用大括号{}定义和引用<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">ylab=&#123;<span class="string">&#x27;周数&#x27;</span>,<span class="string">&#x27;轮虫&#x27;</span>,<span class="string">&#x27;溶氧&#x27;</span>,<span class="string">&#x27;COD&#x27;</span>,<span class="string">&#x27;水温&#x27;</span>,<span class="string">&#x27;PH值&#x27;</span>,<span class="string">&#x27;盐度&#x27;</span>,<span class="string">&#x27;透明度&#x27;</span>,<span class="string">&#x27;总碱度&#x27;</span>,<span class="string">&#x27;氯离子&#x27;</span>,<span class="string">&#x27;透明度&#x27;</span>,<span class="string">&#x27;生物量&#x27;</span>&#125;;  <span class="comment">% 要画的图形的标签</span></span><br></pre></td></tr></table></figure></li><li>向量＋’表示转置</li></ol><h2 id="二-常用函数"><a href="#二-常用函数" class="headerlink" title="二.常用函数"></a>二.常用函数</h2><ol><li>输出</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;Hello Wrold!&#x27;</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>字符串合并</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%1</span></span><br><span class="line">strcat(<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;ABC&#x27;</span>)</span><br><span class="line"><span class="comment">%2</span></span><br><span class="line">[<span class="string">&#x27;abc&#x27;</span> <span class="string">&#x27;ABC&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;ABC&#x27;</span>]</span><br></pre></td></tr></table></figure><ol start="3"><li>将数字转换为字符串</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">c = <span class="number">160</span></span><br><span class="line">num2str(c)</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;c的取值为&#x27;</span>,num2str])</span><br></pre></td></tr></table></figure><ol start="4"><li>输入<br> 一般我们会将输入的数、向量、矩阵、字符串等赋给一个变量，这里我们赋给A。</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = input(<span class="string">&#x27;请输入A：&#x27;</span>);</span><br><span class="line">B = input(<span class="string">&#x27;请输入B：&#x27;</span>)</span><br></pre></td></tr></table></figure><p>加分号时，不输出结果；不加分号时，会输出B的值。</p><ol start="5"><li>sum函数<br>(1)如果是向量（无论是行向量还是列向量），都是直接求和。</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%行向量</span></span><br><span class="line">E = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">sum(E)</span><br><span class="line"><span class="comment">%列向量</span></span><br><span class="line">E = [<span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>]</span><br><span class="line">sum(E)</span><br></pre></td></tr></table></figure><p>(2)如果是矩阵，则需要根据行和列的方向作区分。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">E = [<span class="number">1</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>;<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="comment">%按列求和，得到行向量</span></span><br><span class="line">a = sum(E)</span><br><span class="line">a = sum(E,<span class="number">1</span>)</span><br><span class="line"><span class="comment">%按行求和，得到列向量</span></span><br><span class="line">a = sum(E,<span class="number">2</span>)</span><br><span class="line"><span class="comment">%对整个矩阵求和</span></span><br><span class="line">a = sum(E(:))</span><br><span class="line">a = sum(sum(E))</span><br></pre></td></tr></table></figure><ol start="6"><li><p>提取矩阵指定位置的元素</p><p> (1)取指定行和列的一个元素，输出的是一个值。</p></li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line">A(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">A(<span class="number">3</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>(2)取指定的某一行元素，输出行向量。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line"><span class="comment">% 输出第一行</span></span><br><span class="line">A(:,<span class="number">1</span>)</span><br><span class="line"><span class="comment">% 第二行</span></span><br><span class="line">A(:,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>(3)取指定的某一列的全部元素，输出列向量。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">A(<span class="number">1</span>,:)</span><br><span class="line">A(<span class="number">2</span>,:)</span><br></pre></td></tr></table></figure><p>(4)取指定的某些行的全部元素，输出矩阵</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line"></span><br><span class="line"><span class="comment">% 只取第二行和第五行（一共2行）</span></span><br><span class="line">A([<span class="number">2</span>,<span class="number">5</span>],:)</span><br><span class="line"></span><br><span class="line"> <span class="comment">% 取第二行到第五行（一共4行）</span></span><br><span class="line">A(<span class="number">2</span>:<span class="number">5</span>,:)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 取第二行和第四行 （从2开始，每次递增2个单位，到5结束）</span></span><br><span class="line">A(<span class="number">2</span>:<span class="number">2</span>:<span class="number">5</span>,:)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 输出1，4，7，10</span></span><br><span class="line"><span class="number">1</span>:<span class="number">3</span>:<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 输出10，9，8，···，1</span></span><br><span class="line"><span class="number">10</span>:<span class="number">-1</span>:<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 取第二行到最后一行</span></span><br><span class="line">A(<span class="number">2</span>:<span class="keyword">end</span>,:)</span><br><span class="line"></span><br><span class="line"><span class="comment">%取第二行和倒数第二行</span></span><br><span class="line">A(<span class="number">2</span>:<span class="keyword">end</span><span class="number">-1</span>,:)</span><br></pre></td></tr></table></figure><p>(5)取全部元素，按列拼接最终输出列向量</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">A(:)</span><br></pre></td></tr></table></figure><ol start="7"><li>size函数<br>size(A)函数是用来求矩阵A的大小的,它返回一个行向量，第一个元素是矩阵的行数，第二个元素是矩阵的列数。</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">B = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="built_in">size</span>(A)</span><br><span class="line"><span class="built_in">size</span>(B)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 将矩阵A的行数返回到第一个变量r，列数返回至c</span></span><br><span class="line">[r,c] = <span class="built_in">size</span>(A)</span><br><span class="line">r = <span class="built_in">size</span>(A,<span class="number">1</span>)  <span class="comment">%返回行数</span></span><br><span class="line">c = <span class="built_in">size</span>(A,<span class="number">2</span>) <span class="comment">%返回列数</span></span><br></pre></td></tr></table></figure><ol start="8"><li>repmat函数<br>B = repmat(A,m,n):将矩阵A复制m×n块，即把A作为B的元素，B由m×n个A平铺而成。</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">B = <span class="built_in">repmat</span>(A,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">C = <span class="built_in">repmat</span>(A,<span class="number">3</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><ol start="8"><li>find函数<br>它可以用来返回向量或者矩阵中不为0的元素的位置索引。(索引序号从1开始)，以下是一维向量的用法。</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">X = [<span class="number">1</span> <span class="number">0</span> <span class="number">4</span> <span class="number">-3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">8</span> <span class="number">6</span>]</span><br><span class="line">ind = <span class="built_in">find</span>(X)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 返回前2个不为0的元素的位置</span></span><br><span class="line">ind = <span class="built_in">find</span>(X,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>若X是一个矩阵（二维，有行和列）</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">X = [<span class="number">1</span> <span class="number">-3</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">8</span>;<span class="number">4</span> <span class="number">0</span> <span class="number">6</span>]</span><br><span class="line">ind = <span class="built_in">find</span>(X)</span><br></pre></td></tr></table></figure><p>返回结果ind =1 3 4 8 9，这是因为在Matlab在存储矩阵时，是一列一列存储的。例如输入X(4)，结果将返回为-3。假如你需要按照行列的信息输出，操作如下。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% r代表行，c代表列</span></span><br><span class="line">[r,c] = <span class="built_in">find</span>(X)</span><br><span class="line">[r,c] = <span class="built_in">find</span>(X,<span class="number">1</span>)  <span class="comment">%只找第一个非0元素</span></span><br></pre></td></tr></table></figure><ol start="9"><li>判断语句<br>if所在的行不需要冒号，语句的最后一定要以end结尾；中间的语句要注意缩进。</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">s = input(‘请输入考试分数’)</span><br><span class="line"><span class="keyword">if</span> a &gt;= <span class="number">85</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;优秀&#x27;</span>)</span><br><span class="line"><span class="keyword">elseif</span> a &gt;= <span class="number">60</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;合格&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;不及格&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ol start="10"><li><p>zeros&amp;ones函数<br>生成零矩阵和单位矩阵。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">zeros</span>(<span class="number">3</span>) <span class="comment">% 一个3*3的方阵</span></span><br><span class="line"><span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>) <span class="comment">% 3行1列矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ones</span>(<span class="number">5</span>) <span class="comment">% 一个5*5的方阵</span></span><br><span class="line"><span class="built_in">ones</span>(<span class="number">5</span>,<span class="number">2</span>) <span class="comment">% 5行2列矩阵</span></span><br></pre></td></tr></table></figure></li><li><p>abs绝对值函数、max&amp;min函数</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">X=[<span class="number">2</span> <span class="number">1</span> <span class="number">3</span>;<span class="number">-4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"><span class="built_in">abs</span>(X)</span><br><span class="line">Y=[<span class="number">1</span> <span class="number">0</span> <span class="number">-9</span> <span class="number">8</span> <span class="number">-10</span>]</span><br><span class="line"><span class="built_in">max</span>(Y)</span><br><span class="line"><span class="built_in">min</span>(Y)</span><br></pre></td></tr></table></figure></li><li><p>magic函数<br>幻方矩阵，M = magic(n)返回由1到n^2的整数构成并且总行数和总列数相等的n×n矩阵。阶次n必须为大于或等于3的标量。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A=<span class="built_in">magic</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure></li><li><p>sort排序函数</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>]</span><br><span class="line"><span class="built_in">sort</span>(A) <span class="comment">% 若A是向量不管是列还是行向量，默认都是对A进行升序排列，若A是矩阵，默认对A的各列进行升序排列。</span></span><br><span class="line"><span class="built_in">sort</span>(A,<span class="string">&#x27;descend&#x27;</span>) <span class="comment">% 降序排序</span></span><br><span class="line"><span class="built_in">sort</span>(A,dim) <span class="comment">% dim=1时等效sort(A)，dim=2时表示对A中的各行元素升序排列。</span></span><br><span class="line">[sA,index] = <span class="built_in">sort</span>(A,<span class="string">&#x27;descend&#x27;</span>) <span class="comment">% 若欲保留排列前的索引，则可用[sA,index] = sort(A,&#x27;descend&#x27;)，sA是排序好的向量，index是向量sA中对A的索引。</span></span><br><span class="line"><span class="comment">% 排序后</span></span><br><span class="line"><span class="comment">% sA  =  8     3     2     1</span></span><br><span class="line"><span class="comment">% index =  4     3     1     2</span></span><br></pre></td></tr></table></figure></li><li><p>legend函数<br>用来标注图片</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;ro&#x27;</span>,new_x,p1,<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;原始数据&#x27;</span>,<span class="string">&#x27;三次埃尔米特插值数据&#x27;</span>,<span class="string">&#x27;Location&#x27;</span>,<span class="string">&#x27;SouthEast&#x27;</span>); <span class="comment">% 右下方</span></span><br></pre></td></tr></table></figure></li><li><p>subplot函数</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">subplot(<span class="number">4</span>,<span class="number">3</span>,<span class="built_in">i</span><span class="number">-1</span>);<span class="comment">%将所有图依次变现在4*3的一幅大图上</span></span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line"><span class="number">16.</span> <span class="built_in">plot</span>函数</span><br><span class="line">画图</span><br><span class="line">```matlab</span><br><span class="line"><span class="built_in">plot</span>(x1,y1,x2,y2)</span><br></pre></td></tr></table></figure></li></ol><p>线方式： ‐ 实线  :点线  ‐. 虚点线  ‐ ‐ 波折线<br>点方式： . 圆点  +加号  * 星号  x x形  o 小圆<br>颜色： y黄  r红  g绿  b蓝  w白  k黑  m紫  c青</p><ol start="17"><li><p> axis函数</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">axis([<span class="number">0</span> <span class="number">15</span>,-<span class="built_in">inf</span>,<span class="built_in">inf</span>])  <span class="comment">%设置坐标轴的范围，这里设置横坐标轴0-15，纵坐标不变化</span></span><br></pre></td></tr></table></figure></li><li><p>xlabel&amp;ylabel函数</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">xlabel(<span class="string">&#x27;星期&#x27;</span>)<span class="comment">%x轴标题</span></span><br><span class="line">ylabel(ylab&#123;<span class="built_in">i</span>&#125;)<span class="comment">%y轴标题  这里是直接引用元胞数组中的字符串</span></span><br></pre></td></tr></table></figure></li><li><p>生成随机数函数</p></li></ol><p><strong>randi</strong> : 产生均匀分布的随机整数（i = int）<br><strong>and</strong> : 产生0至1之间均匀分布的随机数<br><strong>normrnd</strong> : 产生正态分布的随机数<br><strong>roundn</strong> : —任意位置四舍五入</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%产生一个1至10之间的随机整数矩阵，大小为2x5；</span></span><br><span class="line">s1 = randi(<span class="number">10</span>,<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment">%产生一个-5至5之间的随机整数矩阵，大小为1x10；</span></span><br><span class="line">s2 = randi([<span class="number">-5</span>,<span class="number">5</span>],<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"><span class="comment">%产生一个0至1之间的随机矩阵，大小为1x5；</span></span><br><span class="line">s3 = <span class="built_in">rand</span>(<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment">%产生一个a至b之间的随机矩阵，大小为1x5；  </span></span><br><span class="line"><span class="comment">% a + (b-a) * rand(1,5); 如：a,b = 2,5</span></span><br><span class="line">s4= <span class="number">2</span> + (<span class="number">5</span><span class="number">-2</span>) * <span class="built_in">rand</span>(<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment">%产生一个均值为0，标准差（方差开根号）为2的正态分布的随机矩阵，大小为3x4；</span></span><br><span class="line">s5 = normrnd(<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">skewness(x) <span class="comment">%偏度</span></span><br><span class="line">kurtosis(x) <span class="comment">%峰度</span></span><br><span class="line"><span class="comment">% 0个位 1十位  2百位 -1小数点后一位  </span></span><br><span class="line">a = <span class="number">3.1415</span></span><br><span class="line">roundn(a,<span class="number">-2</span>)    <span class="comment">% ans   =  3.1400</span></span><br><span class="line">roundn(a,<span class="number">2</span>)      <span class="comment">% ans   =  0</span></span><br><span class="line">a =<span class="number">31415</span></span><br><span class="line">roundn(a,<span class="number">2</span>)   <span class="comment">% ans  = 31400</span></span><br><span class="line">roundn(<span class="number">5.5</span>,<span class="number">0</span>)  <span class="comment">%6</span></span><br><span class="line">roundn(<span class="number">5.5</span>,<span class="number">1</span>) <span class="comment">%10</span></span><br></pre></td></tr></table></figure><ol start="20"><li><p>jbtest函数</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 当输出h等于1时，表示拒绝原假设； h等于0则代表不能拒绝原假设。</span></span><br><span class="line"><span class="comment">% alpha就是显著性水平，一般取0.05，此时置信水平为1‐0.05=0.95</span></span><br><span class="line"><span class="comment">% x就是我们要检验的随机变量,x只能是向量</span></span><br><span class="line">[h,p] = jbtest(x,alpha)</span><br></pre></td></tr></table></figure></li><li><p>相关系数计算函数</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%%Pearson相关系数</span></span><br><span class="line">R = corrcoef(Test) </span><br><span class="line"><span class="comment">% 计算各列之间的相关系数以及p值</span></span><br><span class="line">[R,P] = corrcoef(Test)</span><br><span class="line"></span><br><span class="line"><span class="comment">%%spearman相关系数</span></span><br><span class="line"><span class="comment">% XY必须为列向量</span></span><br><span class="line">coeff = corr(X , Y , <span class="string">&#x27;type&#x27;</span> , <span class="string">&#x27;Spearman&#x27;</span>)</span><br><span class="line"><span class="comment">% 等价于：</span></span><br><span class="line">RX = [<span class="number">2</span> <span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span>]</span><br><span class="line">RY = [<span class="number">1</span> <span class="number">4.5</span> <span class="number">3</span> <span class="number">4.5</span> <span class="number">2</span>]</span><br><span class="line">R = corrcoef(RX,RY)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算矩阵各列的斯皮尔曼相关系数</span></span><br><span class="line">R = corr(Test, <span class="string">&#x27;type&#x27;</span> , <span class="string">&#x27;Spearman&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 直接给出相关系数和p值</span></span><br><span class="line">[R,P]=corr(Test, <span class="string">&#x27;type&#x27;</span> , <span class="string">&#x27;Spearman&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ol><h2 id="三-矩阵运算"><a href="#三-矩阵运算" class="headerlink" title="三.矩阵运算"></a>三.矩阵运算</h2><ol><li>MATLAB在矩阵的运算中，“<em>”号和“/”号代表矩阵之间的乘法与除法(A/B = A</em>inv(B))。</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">B = [<span class="number">1</span>,<span class="number">0</span>;<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">A * B</span><br><span class="line"></span><br><span class="line">inv(B) <span class="comment">% B的逆矩阵</span></span><br><span class="line">B * inv(B)</span><br><span class="line">A * inv(B)</span><br><span class="line">A/B</span><br></pre></td></tr></table></figure><ol start="2"><li>两个形状相同的矩阵对应元素之间的乘除法需要使用“.*”和“./”。</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">B = [<span class="number">1</span>,<span class="number">0</span>;<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">A .* B</span><br><span class="line">A ./ B</span><br><span class="line"></span><br><span class="line"><span class="comment">% 每个元素同时和常数相乘或相除操作，两种方法均可以使用</span></span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">A * <span class="number">2</span></span><br><span class="line">A .*<span class="number">2</span></span><br><span class="line">A / <span class="number">2</span></span><br><span class="line">A ./ <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 每个元素同时乘方只能用.^</span></span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="comment">% 每个元素的平方</span></span><br><span class="line">A .^ <span class="number">2</span></span><br><span class="line"><span class="comment">% 矩阵的平方</span></span><br><span class="line">A ^ <span class="number">2</span></span><br><span class="line">A * A</span><br></pre></td></tr></table></figure><ol start="3"><li>矩阵求特征值和特征向量<br>在Matlab中，计算矩阵A的特征值和特征向量的函数是eig(A)。以下是两个常用的用法。</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>;<span class="number">2</span> <span class="number">2</span> <span class="number">1</span>;<span class="number">2</span> <span class="number">0</span> <span class="number">3</span>]</span><br><span class="line"><span class="comment">% (1) E=eig(A) 求矩阵A的全部特征值，构成向量E</span></span><br><span class="line">E = eig(A)</span><br><span class="line"><span class="comment">% (2) [V,D]=eig(A),求矩阵A的全部特征值，构成对角阵D；</span></span><br><span class="line"><span class="comment">% 并求A的特征向量构成V的列向量</span></span><br><span class="line"><span class="comment">% V的每一列都是D中与之相同列的特征值的特征向量）</span></span><br><span class="line">[V,D]=eig(A)</span><br></pre></td></tr></table></figure><ol start="4"><li>矩阵与常数的大小判断运算<br>共有三种运算符：大于&gt; ;小于&lt; ;等于 ==  （一个等号表示赋值；两个等号表示判断）</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">X = [<span class="number">1</span> <span class="number">-3</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">8</span>;<span class="number">4</span> <span class="number">0</span> <span class="number">6</span>]</span><br><span class="line">X &gt; <span class="number">0</span></span><br><span class="line">x == <span class="number">4</span></span><br><span class="line"><span class="comment">% 输出为一个3x3的逻辑矩阵，&gt;0的位置为1，&lt;0的位置为0</span></span><br></pre></td></tr></table></figure><h2 id="四-工具箱"><a href="#四-工具箱" class="headerlink" title="四.工具箱"></a>四.工具箱</h2><ol><li>cftool(Curve Fitting tool)</li></ol><ul><li>Custom Equations：用户自定义的函数类型</li><li>Exponential：指数逼近，有2种类型， a<em>exp(b</em>x) 、 a<em>exp(b</em>x) + c<em>exp(d</em>x)</li><li>Fourier：傅立叶逼近，有7种类型，基础型是 a0 + a1<em>cos(x</em>w) + b1<em>sin(x</em>w)</li><li>Gaussian：高斯逼近，有8种类型，基础型是 a1*exp(-((x-b1)/c1)^2)</li><li>Interpolant：插值逼近，有4种类型，linear、nearest neighbor、cubic spline、shape-preserving</li><li>Polynomial：多形式逼近，有9种类型，linear ~、quadratic ~、cubic ~、4-9th degree ~</li><li>Power：幂逼近，有2种类型，a<em>x^b 、a</em>x^b + c</li><li>Rational：有理数逼近，分子、分母共有的类型是linear ~、quadratic ~、cubic ~、4-5th degree ~；此外，分子还包括constant型</li><li>Smoothing Spline：平滑逼近（</li><li>Sum of Sin Functions：正弦曲线逼近，有8种类型，基础型是 a1<em>sin(b1</em>x + c1)</li><li>Weibull：只有一种，a<em>b</em>x^(b-1)<em>exp(-a</em>x^b)</li></ul><p>输出：<br>SSE(和方差、误差平方和)：The sum of squares due to error<br>MSE(均方差、方差)：Mean squared error<br>RMSE(均方根、标准差)：Root mean squared error<br>R-square(确定系数)：Coefficient of determination “确定系数”是通过数据的变化来表征一个拟合的好坏。正常取值范围为[0 1]，越接近1，表明方程的变量对y的解释能力越强，这个模型对数据拟合的也较好。<br>Adjusted R-square：Degree-of-freedom adjusted coefficient of determination</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 数学建模 </category>
          
          <category> Matlab基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数学建模 </tag>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML学习笔记</title>
      <link href="/2022/08/07/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/08/07/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML学习笔记-持续更新中···"><a href="#HTML学习笔记-持续更新中···" class="headerlink" title="HTML学习笔记(持续更新中···)"></a>HTML学习笔记(持续更新中···)</h1><pre><code>HTML(Hypertext Makeup Language),超文本标记语言，是一种用于创建网页的标准标记语言。</code></pre><ul><li>标记语言、标记标签</li><li>HTML使用标记标签来描述网页</li><li>HTML文档包含了HTML标签及文本内容</li><li>HTML文档也叫做web页面</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Jupiter&#x27;s note<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>!DOCTYPE html<br>是一条标记语言，具体含义为 HTML5 标准网页声明，全称为 Document Type HyperText Mark-up Language。该声明位于文档中最前面的位置，处于<html>标签之前，支持 HTML5 标准的主流浏览器都认识这个声明，不区分大小写。</li><li>html<br>是 HTML 页面的根元素</li><li>head<br>元素包含了文档的元（meta）数据，如   <meta charset="utf-8">定义网页编码格式为 utf-8。</li><li>title<br>元素描述了文档的标题</li><li>body<br>元素包含了可见的页面内容</li><li>h1<br>元素定义一个大标题</li><li>p<br>元素定义一个段落</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="文档命名"><a href="#文档命名" class="headerlink" title="文档命名"></a>文档命名</h3><ul><li>.html 超文本标记(Hypertext Markup)</li><li>.htm 超文本标记语言(Hypertext Markup Language)</li></ul><h3 id="HTML标签"><a href="#HTML标签" class="headerlink" title="HTML标签"></a>HTML标签</h3><p>HTML标记标签通常被称为HTML标签(HTML tag)。</p><ul><li>HTML 标签是由尖括号包围的关键词，比如 <html></li><li>成对出现，标签对中的第一个标签是开始标签，第二个标签是结束标签，也被称为开放标签和闭合标签。</li></ul><h3 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h3><p>与标签概念相同，但一个 HTML 元素包含了开始标签与结束标签。</p><h3 id="Web浏览器"><a href="#Web浏览器" class="headerlink" title="Web浏览器"></a>Web浏览器</h3><p>用于读取HTML文件，并将其作为网页显示。浏览器并不是直接显示的HTML标签，但可以使用标签来决定如何展现HTML页面的内容给用户。</p><h2 id="HTML基础"><a href="#HTML基础" class="headerlink" title="HTML基础"></a>HTML基础</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>通过h1 - h6 标签来定义。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是标题1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是标题2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是标题3<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>通过标签 p 来定义。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是段落1。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是段落2。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>通过标签 a 来定义，在href属性中指定链接的地址。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://jupitercy.github.io/&quot;</span>&gt;</span>这是一个链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h3><p>通过标签 img 来定义，以属性形式规定图像名称和尺寸。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/images/logo.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;258&quot;</span> <span class="attr">height</span>=<span class="string">&quot;39&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 前端 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Next插入图片</title>
      <link href="/2022/08/04/Hexo-Next%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
      <url>/2022/08/04/Hexo-Next%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo图片无法加载问题"><a href="#Hexo图片无法加载问题" class="headerlink" title="Hexo图片无法加载问题"></a>Hexo图片无法加载问题</h1><pre><code>在第一篇博客中，想要插入一张图片。一番折腾后，终于在本地可以成功显示图片，但在部署到GitHub上之后还是无法加载。在网上搜了很多方法，最终也终于解决了问题。</code></pre><h2 id="图片插入步骤"><a href="#图片插入步骤" class="headerlink" title="图片插入步骤"></a>图片插入步骤</h2><h3 id="Step1"><a href="#Step1" class="headerlink" title="Step1"></a>Step1</h3><p>打开站点配置_config.yml文件，修改以下内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>开启资源文件夹功能，表示在新建博客’hexo new “title”’时，会在根目录下创建一个同名文件夹，我们把要插入的图片存放到这个文件夹里就好啦。</p><img src="/2022/08/04/Hexo-Next%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class="" title="根目录下文件示意图"><img src="/2022/08/04/Hexo-Next%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/%E5%AD%98%E5%9B%BE%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class="" title="将图片存放在对应文件夹里"><h3 id="Step2"><a href="#Step2" class="headerlink" title="Step2"></a>Step2</h3><p>安装插件<strong>hexo-asset-image</strong>，作用是图片路径转换。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><h3 id="Step3"><a href="#Step3" class="headerlink" title="Step3"></a>Step3</h3><p><strong>敲黑板！！！接下来是重点！！</strong></p><p>安装完成后，我们需要修改插件的配置信息。打开/node_modules/hexo-asset-image/index.js，将文件内容替换为以下所示代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getPosition</span>(<span class="params">str, m, i</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">split</span>(m, i).<span class="title function_">join</span>(m).<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="title class_">String</span>(hexo.<span class="property">version</span>).<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.<span class="property">config</span>;</span><br><span class="line">  <span class="keyword">if</span>(config.<span class="property">post_asset_folder</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> link = data.<span class="property">permalink</span>;</span><br><span class="line"><span class="keyword">if</span>(version.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; <span class="title class_">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">   <span class="keyword">var</span> beginPos = <span class="title function_">getPosition</span>(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">var</span> beginPos = <span class="title function_">getPosition</span>(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line"><span class="keyword">var</span> endPos = link.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.<span class="title function_">substring</span>(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.<span class="property">length</span>; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.<span class="title function_">load</span>(data[key], &#123;</span><br><span class="line">        <span class="attr">ignoreWhitespace</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">xmlMode</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">lowerCaseTags</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">decodeEntities</span>: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).<span class="title function_">each</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">if</span> ($(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line"><span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line"><span class="keyword">var</span> src = $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>).<span class="title function_">replace</span>(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.<span class="title function_">test</span>(src) &amp;&amp;</span><br><span class="line">   !<span class="regexp">/^\s*\//</span>.<span class="title function_">test</span>(src)) &#123;</span><br><span class="line">  <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">  <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">  <span class="keyword">var</span> linkArray = link.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">elem</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> srcArray = src.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">elem</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span>(srcArray.<span class="property">length</span> &gt; <span class="number">1</span>)</span><br><span class="line">srcArray.<span class="title function_">shift</span>();</span><br><span class="line">  src = srcArray.<span class="title function_">join</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">  $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>, config.<span class="property">root</span> + link + src);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.<span class="property">root</span> + link + src);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>($(<span class="variable language_">this</span>));</span><br><span class="line">&#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.<span class="title function_">html</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Step4"><a href="#Step4" class="headerlink" title="Step4"></a>Step4</h3><p>准备工作做好了，接下来在对应的md文件中按照以下规则插入图片。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img 图名.png 图片描述 %&#125;</span><br></pre></td></tr></table></figure><h3 id="Step5"><a href="#Step5" class="headerlink" title="Step5"></a>Step5</h3><p>最后一步，还是那套clean+g+d的流程，就可以显示了。</p><p><em>Tips:</em><br><em>如果在Github上部署之后，发现页面没有发生变化，试试‘shift+F5’，说不定就能解决问题。记得一定要等一等，页面可能有延迟，加载比较慢</em></p><h2 id="一个小坑"><a href="#一个小坑" class="headerlink" title="一个小坑"></a>一个小坑</h2><p>在网上查的时候还发现一种方法，我一开始也是使用的这种markdown语法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">![图片描述](/图名.<span class="property">png</span>)</span><br></pre></td></tr></table></figure><p>不过，看了很多相关教程，也没找到有效的能使图片在页面上显示的方法。最终发现似乎是由于版本问题（Hexo 2 v Hexo 3）导致的，感兴趣的uu们可以进一步探究。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Hexo </category>
          
          <category> 常见问题 </category>
          
          <category> Next主题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
            <tag> 常见问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/02/hello-world/"/>
      <url>/2022/08/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
